<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>KIRINUKI RG</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #e67e22;
            --background-color: #f4f6f8;
            --text-color: #34495e;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        
        .container { 
            max-width: 800px; 
            margin: auto; 
        }

        .card {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
            transition: transform 0.3s ease-in-out;
        }
        
        #step1:hover {
            transform: translateY(0);
        }
        #step2:hover, #step3:hover, #stepTrimAndBlur:hover, #stepManualCut:hover { 
            transform: translateY(-5px);
        }

        h1, h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 5px;
            margin-bottom: 20px;
        }

        h3 { 
            color: var(--primary-color);
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: none;
            border-radius: 6px;
            background-color: #ecf0f1;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(44, 62, 80, 0.2);
        }

        .button-group {
            display: flex;
            flex-wrap: wrap; 
            align-items: center;
            gap: 10px;
        }
        
        .button-group button, .button-group select { 
            padding: 10px 15px; 
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        .button-group button {
            background-color: var(--primary-color);
            color: white;
        }

        .button-group button:hover {
            background-color: var(--accent-color);
        }

        .button-group button:active {
            transform: scale(0.98);
        }

        .button-group button.secondary { 
            background-color: #ecf0f1;
            color: var(--text-color);
        }
        .button-group button.secondary:hover { 
            background-color: #dbe4e8;
        }
        .button-group button.secondary.active { 
            background-color: var(--accent-color);
            color: white;
        }
        .button-group button.danger { 
            background-color: #c0392b;
            color: white;
        }
        .button-group button.danger:hover { 
            background-color: #e74c3c;
        }
        .button-group button.history { 
            background-color: #95a5a6;
            color: #000000;
            padding: 10px 12px;
            font-weight: bold;
        }
        .button-group button.history:hover { 
            background-color: #7f8c8d;
        }
        .button-group button.history:disabled { 
            background-color: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .button-group button:disabled,
        .button-group button.disabled,
        #maskGenreControls button:disabled,
        #maskGenreControls button.disabled {
            background-color: #333333 !important;
            color: #777777 !important;
            border: 1px solid #444444 !important;
            cursor: not-allowed !important;
            opacity: 0.6;
            pointer-events: none; 
        }

        body.light-mode .button-group button:disabled,
        body.light-mode .button-group button.disabled,
        body.light-mode #maskGenreControls button:disabled,
        body.light-mode #maskGenreControls button.disabled {
            background-color: #e0e0e0 !important;
            color: #a0a0a0 !important;
            border: 1px solid #cccccc !important;
        }

        .button-group select {
            background-color: #ecf0f1;
            color: var(--text-color);
        }
        
        #statusMessage1, #statusMessage2, #statusMessage3 { 
            margin-top: 20px; 
            font-weight: bold;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 3px solid #ccc;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .slide-in {
            animation: slideInFromTop 1.0s ease-out forwards;
        }

        @keyframes slideInFromTop {
            0% {
                transform: translateY(-20px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .canvas-container { 
            order: 99; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            position: relative; 
            margin-top: 0; 
            margin-bottom: 30px;
        }

        #previewCanvas { 
            border: 1px solid #ccc; 
            max-width: 100%; 
            height: auto; 
            margin-top: 10px;
        }

        #previewCanvas.cut-active { 
            cursor: crosshair;
        }
        #previewCanvas.cut-active.grabbing { 
            cursor: grabbing;
        }
        #previewCanvas.cut-active.pointer { 
            cursor: pointer;
        }
        #previewCanvas.cut-active.adding { 
            cursor: copy;
        }

        #maskGenreControls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        #maskGenreControls button {
            background-color: #ecf0f1;
            color: var(--text-color);
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        #maskGenreControls button:hover {
            background-color: #dbe4e8;
        }
        #maskGenreControls button.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .control-item label {
            width: 42px;
            flex-shrink: 0;
            font-weight: bold;
            font-family: 'Pixelify Sans', sans-serif;
            font-size: 14px;
        }

        /* --- ボタン (◀ ▶) のスタイル --- */
        .control-item .value-control-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            border-radius: 0;
            border: 1px solid var(--primary-color);
            background-color: var(--primary-color);
            color: #000000;
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .control-item .value-control-btn:hover {
            background-color: var(--accent-color);
            color: #000000;
            border-color: var(--accent-color);
        }
        .control-item .value-control-btn:active {
            transform: scale(0.95);
        }

        /* --- 数字入力欄 (Input Number) のスタイル --- */
        .control-item input[type="number"] {
            width: 33px;
            height: 30px; 
            padding: 0 5px;
            text-align: right;
            border-radius: 0; 
            border: 1px solid var(--border-color);
            background-color: var(--input-bg); 
            color: var(--text-color);
            font-family: 'Pixelify Sans', sans-serif;
            font-size: 14px;
            -moz-appearance: textfield; 
        }
        .control-item input[type="number"]::-webkit-outer-spin-button,
        .control-item input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .control-item input[type="number"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--text-color); /* フォーカス時の枠線強調 */
        }

        /* --- スライダー (Range) のスタイル --- */
        .control-item input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            flex-grow: 1;
            height: 30px;
            background: transparent;
            cursor: pointer;
            margin: 0;
        }
        .control-item input[type="range"]:focus {
            outline: none;
        }

        /* レール (Chrome/Edge/Safari) */
        .control-item input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            background: var(--border-color);
            border-radius: 0;
            border: none;
            cursor: pointer;
        }
        
        /* つまみ (Chrome/Edge/Safari) */
        .control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 8px;
            background: var(--text-color);
            border: 1px solid var(--card-bg);
            border-radius: 0;
            cursor: pointer;
            margin-top: -7px;
            box-shadow: none;
        }

        /* レール (Firefox) */
        .control-item input[type="range"]::-moz-range-track {
            width: 100%;
            height: 2px;
            background: var(--border-color);
            border-radius: 0;
            cursor: pointer;
        }

        /* つまみ (Firefox) */
        .control-item input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 8px;
            background: var(--text-color);
            border: 1px solid var(--card-bg);
            border-radius: 0;
            cursor: pointer;
            box-shadow: none;
        }
        
        .hidden { 
            display: none; 
        }

        .adjustment-columns {
            display: flex;
            flex-wrap: wrap; /* 画面が狭い場合は縦積みにする */
            gap: 30px;       /* 左右のカラム間の隙間 */
        }
        .adjustment-column {
            flex: 1;         /* カラム幅を均等に分ける */
            min-width: 300px; /* 最小幅を指定し、これを下回ると折り返す */
        }

        #strayHairControl {
            margin-top: 25px;
            padding-top: 0;
            border-top: none;
        }
        
        #strayHairControl h3 {
            margin-top: 0;
        }

        #strayHairControl .button-group button {
            background-color: #ecf0f1;
            color: var(--text-color);
            font-weight: bold;
        }
        #strayHairControl .button-group button:hover {
            background-color: #dbe4e8;
        }
        #strayHairControl .button-group button.active {
            background-color: var(--accent-color);
            color: white;
        }

        #shapeContextMenu { 
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 5px;
            z-index: 1000;
        }
        #shapeContextMenu button { 
            display: block;
            width: 100%;
            background: none;
            border: none;
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
        }
        #shapeContextMenu button:hover { 
            background-color: #f0f0f0;
        }
        #shapeContextMenu button.delete { 
            color: #c0392b;
        }

        #recoveryPartsContainer {
            margin-top: 10px;
            padding: 10px;
            background-color: var(--input-bg);
            border: none;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 15px;
            min-height: 40px;
        }
        body:not(.light-mode) #recoveryPartsContainer {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .recovery-parts-label {
            font-size: 12px;
            font-weight: bold;
            color: var(--accent-color);
            white-space: nowrap;
            font-family: 'Pixelify Sans', sans-serif;
        }

        .recovery-parts-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .recovery-preview-img {
            height: 40px;
            width: auto;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            border-radius: 0;
            transition: transform 0.2s;
        }
        .recovery-preview-img:hover {
            transform: scale(2.0); /* ホバーで少し大きく確認できるように */
            z-index: 10;
            position: relative;
            border-color: var(--primary-color);
        }
        
        
    /* --- テーマ: モノクロ・ダークモード --- */
    @import url('https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:wght@400;700&display=swap');

    :root {
        --primary-color: #FFFFFF;    
        --accent-color: #AAAAAA;      
        --background-color: #000000; 
        --text-color: #E0E0E0;    
        --card-bg: #080808;
        --border-color: #555555;  
        --input-bg: #333;
    }

    body {
        font-family: 'Pixelify Sans', 'IBM Plex Sans JP', sans-serif; 
        background-color: var(--background-color);
        color: var(--text-color);
        user-select: none; 
        padding: 70px 20px 20px 20px; 
    }

    .card {
        background-color: var(--card-bg);
        border-radius: 0;
        box-shadow: none;
        border: 1px solid var(--border-color);
        position: relative; 
    }
    
    hr {
        border: 0;
        border-top: 1px solid var(--border-color);
        margin-top: 0;
        margin-bottom: 25px;
    }

    h1, h2, h3 {
        font-family: 'Pixelify Sans', 'IBM Plex Sans JP', sans-serif;
    }

    h1, h2 {
        border-bottom: 2px dashed var(--accent-color); 
        margin-top: 0;
    }
    h3 {
        border-bottom: 1px dashed var(--border-color);
    }

    /* フォーム要素のレトロ化 */
    input[type="text"],
    .button-group select {
        border-radius: 0;
        box-shadow: none;
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        user-select: auto;
    }
    input[type="text"]:focus {
        box-shadow: 0 0 0 2px var(--primary-color);
    }

    /* ボタンのレトロ化 */
    .button-group button, 
    .button-group select,
    #maskGenreControls button,
    #strayHairControl .button-group button {
        border-radius: 0;
        font-family: 'Pixelify Sans', 'IBM Plex Sans JP', sans-serif;
    }
    
    /* メインボタン (トークン取得 / 透過実行 / 保存) */
    .button-group button {
        background-color: var(--primary-color);
        color: #000000; 
        border: 1px solid var(--primary-color); 
    }
    .button-group button:hover {
        background-color: var(--accent-color); 
        color: #000000; 
        border: 1px solid var(--accent-color); 
    }
    
    /* セカンダリボタン (図形を配置 / プレビューOn/Off / 透過範囲選択) */
    .button-group button.secondary,
    #maskGenreControls button,
    #strayHairControl .button-group button {
        background-color: #151515; 
        color: var(--primary-color); 
        border: 1px solid var(--border-color);
    }
    .button-group button.secondary:hover,
    #maskGenreControls button:hover,
    #strayHairControl .button-group button:hover {
        background-color: #777; 
        color: var(--primary-color); 
    }
    
    /* アクティブなセカンダリボタン (白塗り) */
    .button-group button.secondary.active,
    #maskGenreControls button.active,
    #strayHairControl .button-group button.active {
        background-color: var(--primary-color); 
        color: #000000; 
        border: 1px solid var(--primary-color); 
    }
    
    /* ★ マニュアル透過ボタン(danger)を白ハイライトに変更 ★ */
    .button-group button.danger {
        background-color: var(--primary-color);
        color: #000000; 
        border: 1px solid var(--primary-color);
    }
    .button-group button.danger:hover {
        background-color: var(--accent-color);
        color: #000000; 
        border: 1px solid var(--accent-color);
    }
    
    /* ★ 暗いテーマ用の無効ボタン スタイル ★ */
    .button-group button.history:disabled,
    .button-group button.danger:disabled {
        background-color: #444;
        color: #888;
        cursor: not-allowed;
        opacity: 0.7;
        border: 1px solid #444;
    }

    .loading::after {
        border: 3px solid var(--border-color);
        border-top-color: var(--primary-color);
        border-radius: 50%;
    }

    .lang-switcher,
    .theme-switcher {
        position: fixed;
        top: 25px;
        display: flex;
        align-items: center;
        height: 26px;
        font-family: 'Noto Sans Mono', 'Noto Sans JP', sans-serif;
        font-size: 14px;
        z-index: 100;
        color: var(--text-color);
    }

    .lang-switcher {
        right: 190px;
    }
    .theme-switcher {
        right: 70px; 
    }
    
    .lang-switcher .lang-btn,
    .theme-switcher .lang-btn {
        background: none;
        border: none;
        color: var(--text-color);
        font-weight: bold;
        cursor: pointer;
        padding: 0 5px;
        font-family: 'Noto Sans Mono', 'Noto Sans JP', sans-serif;
        font-size: 14px;
        opacity: 0.7;
    }
    .lang-switcher .lang-btn.active,
    .theme-switcher .lang-btn.active {
        color: var(--primary-color);
        opacity: 1.0;
    }
    .lang-switcher .lang-separator,
    .theme-switcher .lang-separator {
        margin: 0 -2px;
        font-weight: bold; 
        opacity: 0.7;
    }
    
    /* ライトモード時の文字色を調整 */
    body.light-mode .lang-switcher,
    body.light-mode .theme-switcher {
        color: var(--text-color);
    }
    body.light-mode .lang-switcher .lang-btn,
    body.light-mode .theme-switcher .lang-btn {
        color: var(--text-color);
    }
    body.light-mode .lang-switcher .lang-btn.active,
    body.light-mode .theme-switcher .lang-btn.active {
        color: var(--primary-color);
    }

    .theme-switcher {
        position: fixed; 
        top: 25px;
        right: 70px; 
        display: flex;
        align-items: center;
        font-family: 'Noto Sans Mono', 'Noto Sans JP', sans-serif;
        font-size: 14px;
        z-index: 100; 
    }
    body.light-mode .theme-switcher {
    }

    .contact-link {
        position: fixed;
        top: 27px;
        right: 270px; 
        display: flex;
        align-items: center;
        gap: 5px;
        font-family: 'Pixelify Sans', 'IBM Plex Sans JP', sans-serif;
        font-size: 14px;
        text-decoration: none;
        color: var(--text-color);
        opacity: 0.7;
        z-index: 100;
        transition: opacity 0.2s, color 0.2s;
    }
    .contact-link:hover {
        opacity: 1.0;
        color: var(--primary-color);
    }
    .contact-icon {
        font-size: 16px;
    }
    
    body.light-mode .contact-link {
        color: var(--text-color);
    }
    body.light-mode .contact-link:hover {
        color: var(--primary-color);
    }

    /* ライトモード用の基本色 (モノクロ版) */
    body.light-mode {
        --primary-color: #000000;      
        --accent-color: #555555;      
        --background-color: #FFFFFF;  
        --text-color: #222222;         
        --card-bg: #f9f9f9;           
        --border-color: #AAAAAA;      
        --input-bg: #FFFFFF;       
        font-family: 'Pixelify Sans', 'IBM Plex Sans JP', sans-serif; 
        background-color: var(--background-color);
        color: var(--text-color);
        padding: 70px 20px 20px 20px; 
    }

    /* カード (ライトモード) */
    body.light-mode .card {
        background-color: var(--card-bg);
        border-radius: 0; 
        box-shadow: none; 
        border: 1px solid var(--border-color); 
        transition: background-color 0.3s ease, border-radius 0.1s ease, box-shadow 0.3s ease, border 0.3s ease;
    }
    body.light-mode #step1:hover,
    body.light-mode #step2:hover, 
    body.light-mode #step3:hover, 
    body.light-mode #stepTrimAndBlur:hover, 
    body.light-mode #stepManualCut:hover { 
        transform: translateY(0);
    }


    /* hr (ライトモード) */
    body.light-mode hr {
        border: 0;
        border-top: 1px solid var(--border-color); 
        margin-top: 0;
        margin-bottom: 25px;
    }

    /* 見出し (ライトモード) */
    body.light-mode h1,
    body.light-mode h2,
    body.light-mode h3 {
        font-family: 'Pixelify Sans', 'Noto Sans JP', sans-serif; 
        color: var(--primary-color);
    }
    body.light-mode h1,
    body.light-mode h2 {
        border-bottom: 2px dashed var(--accent-color); 
        margin-top: 0; 
    }
    body.light-mode h3 {
        border-bottom: 1px dashed var(--border-color);
    }

    /* フォーム要素 (ライトモード) */
    body.light-mode input[type="text"],
    body.light-mode .button-group select {
        border-radius: 0; 
        box-shadow: none;
        border: 1px solid var(--border-color); 
        background-color: var(--input-bg);
        color: var(--text-color);
        user-select: auto; 
    }
    body.light-mode input[type="text"]:focus {
        box-shadow: 0 0 0 2px var(--primary-color);
    }

    /* ボタン (ライトモード) */
    body.light-mode .button-group button,
    body.light-mode .button-group select,
    body.light-mode #maskGenreControls button,
    body.light-mode #strayHairControl .button-group button {
        border-radius: 0;
        font-family: 'Pixelify Sans', 'Noto Sans JP', sans-serif; 
    }

    /* メインボタン (ライトモード) */
    body.light-mode .button-group button {
        background-color: var(--primary-color); 
        color: #FFFFFF;
        border: 1px solid var(--primary-color);
    }
    body.light-mode .button-group button:hover {
        background-color: var(--accent-color); 
        color: #FFFFFF; 
        border: 1px solid var(--accent-color);
    }
    body.light-mode .control-item .value-control-btn {
        background-color: var(--primary-color); 
        color: #FFFFFF;
        border: 1px solid var(--primary-color);
    }
    body.light-mode .control-item .value-control-btn:hover {
        background-color: var(--accent-color); 
    }
    body.light-mode #zoomInBtn,
    body.light-mode #zoomOutBtn {
        background-color: var(--primary-color); 
        color: #FFFFFF;
        border: 1px solid var(--primary-color);
    }
    body.light-mode #zoomInBtn:hover,
    body.light-mode #zoomOutBtn:hover {
        background-color: var(--accent-color); 
    }

    /* セカンダリボタン (ライトモード) */
    body.light-mode .button-group button.secondary,
    body.light-mode #maskGenreControls button,
    body.light-mode #strayHairControl .button-group button {
        background-color: #f0f0f0; 
        color: var(--primary-color); 
        border: 1px solid var(--border-color);
    }
    body.light-mode .button-group button.secondary:hover,
    body.light-mode #maskGenreControls button:hover,
    body.light-mode #strayHairControl .button-group button:hover {
        background-color: #dddddd; 
        color: var(--primary-color);
    }

    /* アクティブなセカンダリボタン (ライトモード) */
    body.light-mode .button-group button.secondary.active,
    body.light-mode #maskGenreControls button.active,
    body.light-mode #strayHairControl .button-group button.active {
        background-color: var(--primary-color);
        color: #FFFFFF; 
        border: 1px solid var(--primary-color);
    }

    /* Dangerボタン (ライトモード) */
    body.light-mode .button-group button.danger {
        background-color: var(--primary-color); 
        color: #FFFFFF; 
        border: 1px solid var(--primary-color);
    }
    body.light-mode .button-group button.danger:hover {
        background-color: var(--accent-color);
        border: 1px solid var(--accent-color);
    }

    /* 無効ボタン (ライトモード) */
    body.light-mode .button-group button.history:disabled,
    body.light-mode .button-group button.danger:disabled {
        background-color: #eeeeee; 
        color: #aaaaaa;
        cursor: not-allowed;
        opacity: 0.7;
        border: 1px solid #eeeeee;
    }

    body.light-mode .button-group button.history {
        background-color: #95a5a6; /* ダークモードと同じグレーを維持して区別 */
        color: #000000;
        border: 1px solid #95a5a6;
    }
    body.light-mode .button-group button.history:hover {
        background-color: #7f8c8d; /* ホバー時は少し濃く */
        border: 1px solid #7f8c8d;
    }

    /* ローディング (ライトモード) */
    body.light-mode .loading::after {
        border: 3px solid var(--border-color); /* グレーの円 */
        border-top-color: var(--primary-color); /* 上だけ黒 */
        border-radius: 50%;
    }

    /* 右クリックメニュー (ライトモード) */
    body.light-mode #shapeContextMenu {
        background-color: var(--card-bg);
        border: 1px solid var(--border-color);
        box-shadow: none; 
        border-radius: 0; 
    }
    body.light-mode #shapeContextMenu button {
        background: none;
        color: var(--text-color); 
        border-radius: 0; 
    }
    body.light-mode #shapeContextMenu button:hover {
        background-color: #f0f0f0;
    }
    body.light-mode #shapeContextMenu button.delete {
        color: #c0392b;
    }
        
        #appTitle {
            text-indent: -9999px;
            overflow: hidden;
            width: 100%; 
        }
        #appTitle span {
            display: none;
        }

        /*H1内の動画の基本スタイル */
        #appTitle video {
            width: 100%;
            height: auto;
            display: block; 
            pointer-events: none; 
        }
        #appTitle .logo-video-light {
            display: none;
        }
        body.light-mode #appTitle .logo-video-dark {
            display: none; /* ダークを隠す */
        }
        body.light-mode #appTitle .logo-video-light {
            display: block; /* ライトを表示 */
        }
        
        /* ヘルプアイコン (?) のスタイル (カード内) */
        .help-icon {
            position: absolute;
            top: 20px; 
            right: 20px;
            width: 24px;
            height: 24px;
            background-color: var(--accent-color); 
            color: var(--background-color); 
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: 'Noto Sans JP', sans-serif; 
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s ease, background-color 0.3s ease, color 0.3s ease;
        }
        .help-icon:hover {
            transform: scale(1.1);
        }
        body.light-mode .help-icon {
            color: var(--background-color);
            background-color: var(--accent-color);
        }

        /* モーダルオーバーレイ (背景のブラインド) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }
        
        /* モーダルウィンドウ (ボトムシート形式) */
        .modal-window {
            position: fixed;
            top: 10%;
            left: 0;
            right: 0;
            bottom: 0; 
            background-color: var(--card-bg);
            z-index: 1001;
            box-sizing: border-box;
            display: flex;
            flex-direction: column; 
            
            /* アニメーション（下からスライド） */
            transform: translateY(100%); /* 初期状態: 画面下に隠す */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        /* モーダルが開いたとき（.is-open クラスが付いた時）のスタイル */
        .modal-window.is-open {
            transform: translateY(0); /* 画面内にスライドイン */
        }

        /* モーダル内のテキストスタイル */
        #helpContent {
            flex-grow: 1; /* 残りの高さをすべて埋める */
            overflow-y: auto; 
        }
        .help-content-inner {
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            padding: 30px 40px 40px 40px; 
            box-sizing: border-box;
        }

        .help-content-image {
            max-width: 100%; 
            height: auto;    
            display: block; 
            margin: 25px 0; 
            border: 1px solid var(--border-color); 
            box-sizing: border-box; 
        }
        .help-content-image.no-border {
            border: none;
        }
        #helpContent h2,
        #helpContent h3 {
            margin-top: 25px;
            margin-bottom: 15px;
        }
        #helpContent h2:first-child {
            margin-top: 0; 
        }
        #helpContent p {
            line-height: 1.7;
            margin-bottom: 15px;
        }
        #helpContent small {
            opacity: 0.8;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .modal-handle-bar {
            width: 50px;
            height: 4px;
            background-color: var(--border-color); 
            border-radius: 2px;
            margin: 15px auto;
            flex-shrink: 0; 
            cursor: pointer;
            z-index: 1002;
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }
        .modal-handle-bar:hover {
            opacity: 1;
        }
        .modal-close-btn {
            position: absolute;
            /* ウィンドウの右上「外側」にはみ出す */
            top: -34px;
            right: -1px;
            /* 四角い背景 (□) を設定 */
            width: 32px;
            height: 32px;
            background-color: var(--card-bg); 
            border: 1px solid var(--border-color);
            /* × を中央揃えにする */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px; /* × の文字サイズ調整 */
            line-height: 1; /* 中央揃えのため */
            font-weight: bold;
            color: var(--text-color);
            cursor: pointer;
            z-index: 1002;
            /* 色の transition は背景色も対象にする */
            transition: color 0.2s ease, background-color 0.3s ease;
        }
        .modal-close-btn:hover {
            color: var(--accent-color);
        }
        
        #zoomControlContainer {
            margin-top: 5px;  
            padding-top: 5px; 
            border-top: none; 
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            align-items: center;
            justify-content: center;
            gap: 10px;
            position: relative;
            height: 40px; 
            width: 100%;
        }

        /* 四角いボタン */
        #zoomInBtn, #zoomOutBtn {
            width: 30px;
            height: 30px;
            flex-shrink: 0;
            padding: 0 0 4px 0; 
            border-radius: 0; 
            border: 1px solid var(--primary-color);
            background-color: var(--primary-color); 
            color: #000000; 
            font-family: 'Pixelify Sans', sans-serif;
            font-size: 18px;
            
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0;
        }
        #zoomInBtn:hover, #zoomOutBtn:hover {
            background-color: var(--accent-color);
            color: #000000;
            border-color: var(--accent-color);
        }
        #zoomInBtn:active, #zoomOutBtn:active {
            transform: scale(0.95);
        }

        /* スライダーと目盛りのラッパー */
        .zoom-slider-wrapper {
            position: relative;
            flex-grow: 1;
            max-width: 400px;
            height: 30px;
            display: flex;
            align-items: center;
            margin: 0 5px;
            padding-bottom: 0;
            margin-bottom: 0; 
        }

        /* スライダー本体 */
        #zoomSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 100%;
            background: transparent;
            margin: 0;
            cursor: pointer;
            z-index: 2;
            position: relative;
        }
        #zoomSlider:focus { outline: none; }

        /* レール (Chrome/Edge) */
        #zoomSlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: 0;
            border: none;
        }
        /* つまみ (Chrome/Edge) */
        #zoomSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 8px;
            background: var(--text-color);
            border: 1px solid var(--card-bg);
            border-radius: 0;
            cursor: pointer;
            margin-top: -7px;
            box-shadow: none;
        }
        /* レール (Firefox) */
        #zoomSlider::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: var(--border-color);
            border-radius: 0;
        }
        /* つまみ (Firefox) */
        #zoomSlider::-moz-range-thumb {
            height: 16px;
            width: 8px;
            background: var(--text-color);
            border: 1px solid var(--card-bg);
            border-radius: 0;
            cursor: pointer;
            box-shadow: none;
        }

        /* 目盛り (Ticks) コンテナ */
        .zoom-ticks {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 10px;
            transform: translateY(-50%);
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 1;
            padding: 0 4px;
            box-sizing: border-box;
        }

        /* 個別の目盛りと数値 */
        .zoom-tick {
            position: absolute;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Noto Sans Mono', monospace;
            font-size: 10px; 
            color: var(--accent-color);
            margin-top: 18px; 
            cursor: pointer;
            pointer-events: auto;
            transition: color 0.2s, font-weight 0.2s;
        }
        .zoom-tick:hover {
            color: var(--primary-color);
            font-weight: bold;
        }
        .zoom-tick::before {
            content: '';
            position: absolute;
            top: -10px;
            width: 2px;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 0;
        }

        /* ラベル */
        #zoomValueLabel {
            font-family: 'Pixelify Sans', sans-serif;
            width: 50px; 
            text-align: right; 
            font-weight: normal;
            font-size: 16px;
            flex-shrink: 0;
            white-space: nowrap;
            margin-bottom: 0; 
        }

        #statusMessage3:empty {
            display: none;
            margin: 0;
            padding: 0;
        }

        /* 拡大中のキャンバスコンテナ制御 */
        #stepCanvasContainer {
            overflow: hidden; /* 拡大時にはみ出した部分を隠す（マスクの役割） */
            /* コンテナを「表示範囲の境界」として機能させるために枠線をつける */
            border: 1px solid var(--border-color); 
            /* コンテナを強制的に正方形にする */
            aspect-ratio: 1 / 1;
            background-color: transparent; 
            position: relative;
            width: 100%;
            max-width: 100%; 
        }

        #stepCanvasContainer:not(.hidden) {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column; 
        }
        
        /* キャンバス自体のスタイル調整 */
        #previewCanvas {
            transform-origin: center center;
            /* 画像自体の枠線を消す（コンテナの枠線を表示範囲とするため） */
            border: none;
            box-shadow: none;
            transition: transform 0.05s ease-out;
            /* コンテナ（正方形）いっぱいに広げる */
            width: 100%;
            height: 100%; 
            object-fit: contain; /* アスペクト比を維持して収める */
            display: block;
            margin-top: 0;
        }

        #stepCanvasContainer.grab-cursor {
            cursor: grab;
        }
        #stepCanvasContainer.grabbing-cursor {
            cursor: grabbing;
        }


    </style>
</head>
<body>

    <a href="https://docs.google.com/forms/d/e/1FAIpQLSdz7H2e8CXTqP5k3IKykFul0abysCyIdC_j9FfP1MU_X0KvkA/viewform?usp=dialog" target="_blank" class="contact-link" title="Contact / お問い合わせ">
        <span class="contact-icon">✉</span> 
        <span class="contact-text" data-lang-jp="Contact" data-lang-en="Contact">Contact</span>
    </a>
    
    <div class="lang-switcher">
        <button id="langJpBtn" class="lang-btn active" data-lang-jp="JP" data-lang-en="JP">JP</button>
        <span class="lang-separator">/</span>
        <button id="langEnBtn" class="lang-btn" data-lang-jp="EN" data-lang-en="EN">EN</button>
    </div>
    <div class="theme-switcher">
        <button id="themeDarkBtn" class="lang-btn" data-lang-jp="DARK" data-lang-en="DARK">DARK</button>
        <span class="lang-separator">/</span>
        <button id="themeLightBtn" class="lang-btn" data-lang-jp="LIGHT" data-lang-en="LIGHT">LIGHT</button>
    </div>
    <span class="help-icon"
        data-help-target="step0" 
        data-image-jp-dark="picture/step0_jp_dark.png" 
        data-image-jp-light="picture/step0_jp_light.png" 
        data-image-en-dark="picture/step0_en_dark.png" 
        data-image-en-light="picture/step0_en_light.png" 
        style="position: fixed; top: 25px; right: 30px; z-index: 101;">?</span>
    
    <div class="container">
        <h1 id="appTitle">
            <span data-lang-jp="KRG 透過処理ツール" data-lang-en="KRG Masking Tool">KRG 透過処理ツール</span>
    
            <video
                class="logo-video-dark"
                src="picture/KIRINUKI_RG_Black_Movie.mp4" 
                autoplay 
                muted 
                playsinline
            >
                動画ロゴ (Dark)
            </video>
            <video 
                class="logo-video-light"
                src="picture/KIRINUKI_RG_White_Movie.mp4" 
                autoplay 
                muted 
                playsinline
            >
                動画ロゴ (Light)
            </video>
        </h1>

        <div id="step1" class="card">
            <span class="help-icon" 
                data-help-target="step1"
                data-image-jp-dark="picture/step1_jp_dark.png" 
                data-image-jp-light="picture/step1_jp_light.png" 
                data-image-en-dark="picture/step1_en_dark.png" 
                data-image-en-light="picture/step1_en_light.png">?</span> 
            <h2 data-lang-jp="Step 1: トークンID入力" 
                data-lang-en="Step 1: Enter Token ID">
                ステップ1: トークンID入力
            </h2>
            
            <input type="text" id="tokenIdInput" placeholder="トークンIDを入力" 
                   data-lang-placeholder-jp="KRGのトークンIDを半角数字(例：#1なら1)で入力" 
                   data-lang-placeholder-en="Enter the Token ID of the KRG (e.g., 1 for #1)">
            <div class="button-group">
                <button id="fetchDataBtn" data-lang-jp="トークンデータ取得" data-lang-en="Fetch Token Data">トークンデータ取得</button>
                
                <button id="fetchDataLightBtn" 
                    data-lang-jp="軽量モードで取得" 
                    data-lang-en="Lightweight Mode"
                    title="4K解像度で処理を行い、メモリ使用量を抑えます">
                    軽量モードで取得 (4K)
                </button>
                </div>
            <div id="statusMessage1"></div>
        </div>
        
        <div id="step2" class="card hidden">
            <span class="help-icon" 
                data-help-target="step2"
                data-image-jp-dark="picture/step2_jp_dark.png" 
                data-image-jp-light="picture/step2_jp_light.png" 
                data-image-en-dark="picture/step2_en_dark.png" 
                data-image-en-light="picture/step2_en_light.png">?</span> 
            <h2 data-lang-jp="Step 2: 切り抜き条件選択" 
                data-lang-en="Step 2: Select Masking Options">
                ステップ2: 切り抜き範囲の選択
            </h2>

            <h3 data-lang-jp="切り抜き範囲指定" data-lang-en="Select Area">切り抜き範囲指定</h3>
            <div id="maskGenreControls">
                <button id="headBtn" data-lang-jp="頭系" data-lang-en="Head">頭系</button>
                <button id="headBodyBtn" data-lang-jp="頭系＋体系" data-lang-en="Head + Body">頭系＋体系</button>
                <button id="headBodyBgBtn" data-lang-jp="頭系＋体系＋背景系" data-lang-en="Head + Body + Background">頭系＋体系＋背景系</button>
            </div>

            <h3 data-lang-jp="切り抜きモード指定" data-lang-en="Select Mode">切り抜きモード指定</h3>
            <div id="maskModeControls" class="button-group">
                <button id="modeNormalBtn" class="secondary active" data-lang-jp="通常モード" data-lang-en="Normal Mode">通常モード</button>
                <button id="modeRecoveryBtn" class="secondary" data-lang-jp="補完モード" data-lang-en="Recovery Mode">補完モード</button>
                </div>

            <div id="recoveryPartsContainer" class="hidden">
                <span class="recovery-parts-label" data-lang-jp="補完パーツ:" data-lang-en="Recovery Parts:">補完パーツ:</span>
                <div id="recoveryPartsList" class="recovery-parts-list">
                    </div>
            </div>

            <div id="strayHairControl" class="hidden">
                <h3 data-lang-jp="ヘアノイズ除去" data-lang-en="Stray Hair Fix">肩周り補正</h3>
                <div class="button-group">
                    <button id="strayHairFixOnBtn" data-lang-jp="ON" data-lang-en="ON">ON</button>
                    <button id="strayHairFixOffBtn" class="active" data-lang-jp="OFF" data-lang-en="OFF">OFF</button>
                </div>
            </div>

            <div class="button-group" style="margin-top: 60px;">
                <button id="doPreviewBtn" data-lang-jp="プレビュー表示" data-lang-en="Show Preview">プレビュー表示</button>
                <button id="doExecuteBtn" data-lang-jp="切り抜き実行" data-lang-en="Apply Masking">切り抜き実行</button>
                </div>
            
            <div id="statusMessage2"></div>
        </div>

        <div id="stepManualCut" class="card hidden">
            <span class="help-icon" 
                data-help-target="step3"
                data-image-jp-dark="picture/step3_jp_dark.png" 
                data-image-jp-light="picture/step3_jp_light.png" 
                data-image-en-dark="picture/step3_en_dark.png" 
                data-image-en-light="picture/step3_en_light.png">?</span> 
            <h2 data-lang-jp="Step 3: マニュアル切り抜き" 
                data-lang-en="Step 3: Manual Masking">
                ステップ3: マニュアル透過
            </h2>
            <div id="manualCutControls">


                <div class="button-group">
                    <button id="addShapeBtn" class="secondary" data-lang-jp="図形を配置" data-lang-en="Add Shape">図形を配置</button>
                    <button id="undoBtn" class="history" disabled data-lang-jp="元に戻す (Ctrl+Z)" data-lang-en="Undo (Ctrl+Z)">元に戻す (Ctrl+Z)</button>
                    <button id="redoBtn" class="history" disabled data-lang-jp="やり直す (Ctrl+Y)" data-lang-en="Redo (Ctrl+Y)">やり直す (Ctrl+Y)</button>
                </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button id="applyManualCutBtn" class="danger" disabled data-lang-jp="切り抜き実行" data-lang-en="Apply Masking" style="min-width: 200px;">マニュアル透過処理</button>
                </div>

                <div id="zoomControlContainer">
                    <button id="zoomOutBtn" class="secondary">-</button>

                    <div class="zoom-slider-wrapper">
                        <input type="range" id="zoomSlider" min="80" max="400" step="10" value="100">
                        <div id="zoomTicks" class="zoom-ticks">
                            </div>
                    </div>

                    <button id="zoomInBtn" class="secondary">+</button>
                    
                    <span id="zoomValueLabel" style="width: 50px; text-align: right; font-weight: bold;">100%</span>
                </div>
                <div id="statusMessage3"></div>
            </div>
        </div>

        <div id="stepCanvasContainer" class="canvas-container hidden"> 
            <canvas id="previewCanvas"></canvas>
            <div id="shapeContextMenu">
                <button id="ctxAddVertex" data-lang-jp="頂点を追加" data-lang-en="Add Vertex">頂点を追加</button>
                <button id="ctxDeleteVertex" class="delete" data-lang-jp="頂点を削除" data-lang-en="Delete Vertex">頂点を削除</button>
                <button id="ctxDeleteShape" class="delete" data-lang-jp="図形を削除" data-lang-en="Delete Shape">図形を削除</button>
                <button id="ctxCancel" data-lang-jp="閉じる" data-lang-en="Close">閉じる</button>
            </div>
        </div>

        <div id="stepTrimAndBlur" class="card hidden">
            <span class="help-icon"
                data-help-target="step4" 
                data-image-jp-dark="picture/step4_jp_dark.png" 
                data-image-jp-light="picture/step4_jp_light.png" 
                data-image-en-dark="picture/step4_en_dark.png" 
                data-image-en-light="picture/step4_en_light.png">?</span> 
            <h2 data-lang-jp="Step 4: トリミング＆境界ぼかし" 
                data-lang-en="Step 4: Trim & Border Blur"> ステップ4: 調整 (トリミング＆ぼかし)
            </h2>

            <div class="adjustment-columns">

                <div id="cropControls" class="adjustment-column">
                    <h3 data-lang-jp="トリミング" data-lang-en="Trimming">トリミング</h3>
                    <div class="control-group">
                        
                        <div class="control-item">
                            <label data-lang-jp="上端" data-lang-en="Top">上端</label>
                            <button class="value-control-btn" data-target="cropTop" data-direction="minus">◀</button>
                            <input type="range" id="cropTopSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="cropTop" data-direction="plus">▶</button>
                            <input type="number" id="cropTopInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="右端" data-lang-en="Right">右端</label>
                            <button class="value-control-btn" data-target="cropRight" data-direction="minus">◀</button>
                            <input type="range" id="cropRightSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="cropRight" data-direction="plus">▶</button>
                            <input type="number" id="cropRightInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="左端" data-lang-en="Left">左端</label>
                            <button class="value-control-btn" data-target="cropLeft" data-direction="minus">◀</button>
                            <input type="range" id="cropLeftSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="cropLeft" data-direction="plus">▶</button>
                            <input type="number" id="cropLeftInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="下端" data-lang-en="Bottom">下端</label>
                            <button class="value-control-btn" data-target="cropBottom" data-direction="minus">◀</button>
                            <input type="range" id="cropBottomSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="cropBottom" data-direction="plus">▶</button>
                            <input type="number" id="cropBottomInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        </div>
                </div>

                <div id="blurControls" class="adjustment-column">
                    <h3 data-lang-jp="境界ぼかし" data-lang-en="Border Blur">境界ぼかし</h3>
                    <div class="control-group">

                        <div class="control-item">
                            <label data-lang-jp="上端" data-lang-en="Top">上端</label>
                            <button class="value-control-btn" data-target="blurTop" data-direction="minus">◀</button>
                            <input type="range" id="blurTopSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="blurTop" data-direction="plus">▶</button>
                            <input type="number" id="blurTopInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="右端" data-lang-en="Right">右端</label>
                            <button class="value-control-btn" data-target="blurRight" data-direction="minus">◀</button>
                            <input type="range" id="blurRightSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="blurRight" data-direction="plus">▶</button>
                            <input type="number" id="blurRightInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="左端" data-lang-en="Left">左端</label>
                            <button class="value-control-btn" data-target="blurLeft" data-direction="minus">◀</button>
                            <input type="range" id="blurLeftSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="blurLeft" data-direction="plus">▶</button>
                            <input type="number" id="blurLeftInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                        <div class="control-item">
                            <label data-lang-jp="下端" data-lang-en="Bottom">下端</label>
                            <button class="value-control-btn" data-target="blurBottom" data-direction="minus">◀</button> 
                            <input type="range" id="blurBottomSlider" min="0" max="100.0" step="0.1" value="0">
                            <button class="value-control-btn" data-target="blurBottom" data-direction="plus">▶</button> 
                            <input type="number" id="blurBottomInput" min="0" max="100.0" step="0.1" value="0"> %
                        </div>
                    </div></div></div><div class="button-group" style="margin-top: 15px;">
                <button id="toggleAdjustmentsPreviewBtn" class="secondary active" data-lang-jp="プレビュー: On" data-lang-en="Preview: On">調整プレビュー: On</button>
            </div>
            
        
        </div><div id="step3" class="card hidden"> 
            <span class="help-icon" 
                data-help-target="step5"
                data-image-jp-dark="picture/step5_jp_dark.png" 
                data-image-jp-light="picture/step5_jp_light.png" 
                data-image-en-dark="picture/step5_en_dark.png" 
                data-image-en-light="picture/step5_en_light.png">?</span> 
            <h2 data-lang-jp="Step 5: 画像の保存" 
                data-lang-en="Step 5: Save Image">
                ステップ5: 透過画像の保存
            </h2>
<!--            <p data-lang-jp="透過処理が完了しました。保存サイズを選んで画像を保存してください。"
               data-lang-en="Masking complete. Select a save size and save the image.">
               透過処理が完了しました。保存サイズを選んで画像を保存してください。
            </p>-->
            <div class="button-group">
                <label data-lang-jp="保存サイズ: " data-lang-en="Save Size: ">保存サイズ: </label>
                <select id="saveSizeSelect">
                    <option value="16384" selected data-lang-jp="最高 (16384px)" data-lang-en="Max (16384px)">オリジナル (16384px)</option>
                    <option value="3840" data-lang-jp="4K (3840px)" data-lang-en="4K (3840px)">4K (3840px)</option>
                    <option value="2560" data-lang-jp="QHD (2560px)" data-lang-en="QHD (2560px)">QHD (2560px)</option>
                    <option value="1920" data-lang-jp="FHD (1920px)" data-lang-en="FHD (1920px)">FHD (1920px)</option>
                    <option value="1080" data-lang-jp="HD (1080px, NFT Original)" data-lang-en="HD (1080px, NFT Original)">HD (1080px, NFT Original)</option>
                </select>
                <button id="saveImageBtn" data-lang-jp="画像を保存" data-lang-en="Save Image">透過画像を保存</button>
            </div>
        </div>
    </div>
    <div id="debugPanel" style="display: none; margin-top: 50px; padding: 20px; border-top: 2px dashed #ccc; background-color: #f0f0f0; color: #333;">
        <h3>🔧 デバッグ・バッチ処理</h3>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <label>開始ID: <input type="number" id="batchStartId" value="1" style="width: 60px;"></label>
            <label>終了ID: <input type="number" id="batchEndId" value="5" style="width: 60px;"></label>
            <button id="startBatchBtn" style="background-color: #333; color: #fff; padding: 5px 15px;">一括処理開始</button>
            <button id="stopBatchBtn" style="background-color: #c0392b; color: #fff; padding: 5px 15px;" disabled>停止</button>
        </div>
        <div id="batchLog" style="height: 150px; overflow-y: scroll; background: #fff; border: 1px solid #999; padding: 10px; font-family: monospace; font-size: 12px;">
            ログ待機中...
        </div>
    </div>
    <div id="helpModalOverlay" class="modal-overlay hidden"></div>
    
    <div id="helpModal" class="modal-window"> <div id="closeModalHandle" class="modal-handle-bar"></div>
        
        <div id="helpContent">
            <div class="help-content-inner">
            <div data-help-id="step0">
                <img 
                    src="picture/step0_jp_dark.png" 
                    alt="ヘルプ用画像" 
                    class="help-content-image dynamic-help-image no-border"
    
                    data-src-jp-dark="picture\KIRINUKI_RG_Black_help.png"
                    data-src-jp-light="picture\KIRINUKI_RG_White_help.png"
    
                    data-lang-alt-jp="ヘルプ用画像"
                    data-lang-alt-en="Help Image"
                >
                <h2 data-lang-jp="KIRINUKI RG へようこそ" data-lang-en="Welcome to KIRINUKI RG">KIRINUKI RG へようこそ</h2>
                <p data-lang-jp="KIRINUKI RGは、KRGの二次的な活用を支援するための画像切り抜きツールです。以下の5つのStepで、簡単に切り抜き画像を作成できます。"
                   data-lang-en="KIRINUKI RG is an image masking tool to support the secondary use of KRG. You can easily create masked images in the following 5 steps.">
                   KIRINUKI RGは、KRGの二次的な活用を支援するための画像切り抜きツールです。以下の5つのStepで、簡単に高解像度の切り抜き画像を作成できます。
                </p>

                <h3 data-lang-jp="Step 1: トークンID入力" data-lang-en="Step 1: Enter Token ID">Step 1: パーツ情報の自動解析</h3>
                <p data-lang-jp="トークンIDを入力するだけで、KRGのパーツ情報を自動で読み込みます。" data-lang-en="Simply enter the Token ID to automatically load all part information for the KRG.">トークンIDを入力するだけで、KRGのパーツ情報を自動で読み込みます。</p>

                <h3 data-lang-jp="Step 2: 切り抜き条件選択" data-lang-en="Step 2: Select Masking Options">Step 2: 自動切り抜き</h3>
                <p data-lang-jp="切り抜き条件を選ぶだけで、複雑なレイヤーマスクを自動で合成し切り抜き画像を作成できます。" 
                data-lang-en="Simply select a masking mode to automatically composite the complex layer masks and create a masked image.">切り抜きモード（頭/体/背景）を選ぶだけで、複雑なレイヤーマスクを自動で合成し切り抜き画像を作成します。<br>
                   <small data-lang-jp="※半透明のパーツ (IV, Umbrella, Face Shield Black) は“補完切り抜き”を実行することで再現パーツを表示できます。" 
                   data-lang-en="Note: For translucent parts (IV, Umbrella, Face Shield Black), replicated parts can be displayed by running the Recovery Masking process.">※半透明のパーツ (IV, Umbrella, Face Shield Black) は“補完切り抜き”を実行することで再現パーツを表示できます。</small>
                </p>

                <h3 data-lang-jp="Step 3: マニュアル切り抜き" data-lang-en="Step 3: Manual Masking">Step 3: マニュアル切り抜き</h3>
                <p data-lang-jp="自動切り抜きで残った不要な部分を図形ツールで直感的に削除できます。" 
                data-lang-en="You can intuitively remove any unwanted parts left over from the auto-masking process using the shape tool.">自動切り抜きで残った不要な部分を図形ツールで直感的に削除できます。</p>
                
                <h3 data-lang-jp="Step 4: トリミング＆境界ぼかし" data-lang-en="Step 4: Trim & Border Blur">Step 4: トリミング＆境界ぼかし</h3>
                <p data-lang-jp="トリミングや境界線のぼかしを行って、画像の仕上がりを調整できます。" 
                data-lang-en="You can adjust the image's finish by applying trimming or blurring the borders.">トリミングや境界線のぼかしを行って、画像の仕上がりを調整できます。</p>

                <h3 data-lang-jp="Step 5: 画像の保存" data-lang-en="Step 5: Save Image">Step 5: 画像の保存</h3>
                <p data-lang-jp="4KやFHDなど解像度を選択して保存できます。（最大16384px）" 
                data-lang-en="You can select a resolution such as 4K or FHD to save. (Max 16384px)">4KやFHDなど解像度を選択して保存できます。（最大16384px）</p>
                <br>
                <br>
                <hr style="margin-top: 25px;">
                <br>
                <h3 data-lang-jp="注意事項" data-lang-en="Important Notes">注意事項</h3>
                <ul>
                    <li data-lang-jp="自らが保有していないKRGの使用はマナー違反です。" data-lang-en="Using a KRG you do not own is bad manners.">自らが保有していないKRGの使用はマナー違反です。</li>
                    <li data-lang-jp="切り抜きはアート作品を加工する行為です。作者へのリスペクトを持って使用しましょう。" data-lang-en="Masking is an act that modifies an artwork. Please use this tool with respect for the original artist.">切り抜きはアート作品に加工を加える行為です。作者へのリスペクトを持って使用しましょう。</li>
                    <li data-lang-jp="このWebアプリの利用には、いかなるWalletの情報も必要としません。情報を求められた場合は、このアプリを模倣した詐欺サイトにアクセスしている可能性があります。" data-lang-en="This web app NEVER requires any wallet information. If you are asked for such details, you are likely accessing a scam site mimicking this application."></li>
                    <li data-lang-jp="トークンIDを調べるために各種サイトにアクセスする際は、KAMITSUBAKI Co-Creation公式Discordサーバーに掲載されているURLなど、必ず公式が管理しているURLからアクセスするようにしましょう。公式以外のURLは詐欺サイトの可能性があり、アクセスするだけであなたのKRGが盗まれる危険性があります。" data-lang-en="To verify Token IDs, ONLY use URLs from official sources like the KAMITSUBAKI Co-Creation Official Discord. Visiting unofficial sites carries a high risk of fraud, and your KRG could be stolen just by clicking the link."></li>

                </ul>
                <br>

                <h3 data-lang-jp="お問い合わせ" data-lang-en="Contact">お問い合わせ</h3>
                <p data-lang-jp="ツールの不具合報告、機能追加の要望、その他ご質問等は以下のフォームより受け付けています。"
                   data-lang-en="Please use the form below for bug reports, feature requests, and other inquiries.""
                   ツールの不具合報告、機能追加の要望、その他ご質問等は以下のフォームより受け付けています。<br>
                   開発者は個人のため即座の対応は難しい場合がありますが、今後の開発の参考にさせていただきます。
                </p>
                
                <div style="margin: 20px 0; text-align: center;">
                    <a href="https://docs.google.com/forms/d/e/1FAIpQLSdz7H2e8CXTqP5k3IKykFul0abysCyIdC_j9FfP1MU_X0KvkA/viewform?usp=dialog" target="_blank" style="text-decoration: none;">
                        <button class="secondary" style="padding: 12px 24px; font-weight: bold; cursor: pointer;"
                            data-lang-jp="お問い合わせフォームを開く" 
                            data-lang-en="Open Contact Form">
                            お問い合わせフォームを開く
                        </button>
                    </a>
                </div>
                <p data-lang-jp="[更新日 : 2025年12月14日]" data-lang-en="[Last updated: December 14, 2025]">
                <ul>
                    <li data-lang-jp="#225, #462, #1635, #2651はKRG画像自体に不具合があり、切り抜き範囲がずれています。" data-lang-en="For #225, #462, #1635, and #2651, the masking area is misaligned due to defects in the KRG images themselves."></li>
                </ul>
                <br>

                <h3 data-lang-jp="FAQ" data-lang-en="FAQ">FAQ</h3>
                <p data-lang-jp="Q. <br>サイトにアクセスしたときに、変な画面が表示される。<br>
                    A. <br>これはサーバー再起動時の待機画面であり、仕様です。このWebアプリはRenderという無料サーバーを利用しています。サーバー運用最適化のため、最終アクセスから約15分経過すると自動的にサーバーが閉じ、新規アクセスに対してはサーバー起動待機画面が表示されるようになります。
                    <br><br>Q. <br>トークンID取得が完了したのに、KRG画像が表示されない。
                    <br>A. GPUの処理能力によっては正しく進行しない場合があります。十分なGPU処理能力を確保したうえで、もう一度トークンID取得ボタンをクリックしてください。
                    <br><br>Q. <br>特定の切り抜きモードを選択したのに、異なった切り抜き範囲が表示される。
                    <br>A. <br>GPUの処理能力によっては、切り抜き範囲を指定するレイヤー処理が正しく完了しない場合があります。十分なGPU処理能力を確保したうえで、もう一度切り抜きモードを選択してください。
                    <br><br>Q. <br>切り抜き画像の輪郭線に、背景の色が映り込んでいる。
                    <br>A. <br>仕様です。KRGの作品は不可逆的な圧縮を受けていると考えられ、黒い輪郭線の縁には背景の色がランダムな強さで映り込んでいます。できるだけ映り込みの少ない範囲を切り抜くよう設計しましたが、圧縮のされ方によっては背景の色が強く映り込む場合があります。また、輪郭線と塗りつぶしの範囲が一致しない領域や、そもそも輪郭線が存在しない領域もあるため、境界線の切り抜き方には若干のブレがあります。
                    <br><br>Q. <br>とあるパーツの切り抜き範囲がずれている。
                    <br>A. <br>使用されているパーツ名が同じでも、パーツの描画範囲が異なっている例が稀にあります。これまでに確認できたものについては対応済みですが、対応できていないパーツである可能性があります。
                    <br><br><br><br>
                    "  
                    data-lang-en="Q. <br>I see a weird screen when I access the site.
                    <br>A. <br>This is a waiting screen for the server to restart, which is by design. This web app uses a free server (Render). To optimize server operation, the server automatically shuts down after about 20 minutes of inactivity. When new access occurs, this server startup waiting screen will be displayed.
                    <br><br>Q. <br>The KRG image doesn't appear even after fetching the Token ID.
                    <br>A. <br>Processing may not proceed correctly depending on your GPU's capabilities. Please ensure you have sufficient GPU power and try clicking the Fetch Token Data button again.
                    <br><br>Q. <br>The background color is bleeding into the outline of the masked image.
                    <br>A. <br>This is by design. KRG artworks appear to have undergone lossy compression, causing background colors to randomly bleed into the edges of black outlines. While the tool is designed to mask the cleanest area possible, strong color bleeding may occur depending on the compression. Additionally, there are areas where outlines do not match the fill, or where no outline exists, causing slight variations in the masking.
                    <br><br>Q. <br>The mask area for a certain part is misaligned.
                    <br>A. <br>In rare cases, parts with the same name may have different drawing areas. We have addressed the cases confirmed so far, but it's possible this is a part we have not yet accounted for.
                    <br><br><br><br>
                    ">
                    </p>
                <small data-lang-jp="created by 2121" data-lang-en="created by 2121"></small>
            
            
                </div>

            <div data-help-id="step1" class="hidden">
                <h2 data-lang-jp="Step 1: トークンID入力" data-lang-en="Step 1: Enter Token ID">Step 1: トークンID入力</h2>
                <p data-lang-jp="このStepでは、入力されたトークンIDをもとにKRGのパーツ情報を読み込みます。" 
                data-lang-en="In this step, the KRG's part information is loaded based on the entered Token ID."></p>
                <br>
                <h3 data-lang-jp="a. KRGのトークンIDの確認" data-lang-en="a. KRG Token ID Confirmation"></h3>
                <p data-lang-jp="OpenseaやMetaMask等、保有しているKRGを確認できるサイトでトークンIDを確認します。
                                <br>＜警告＞
                                <br>トークンIDを調べるために各種サイトにアクセスする際は、KAMITSUBAKI Co-Creation公式Discordサーバーに掲載されているURLなど、必ず公式が管理しているURLからアクセスするようにしましょう。公式以外のURLは詐欺サイトの可能性があり、アクセスするだけであなたのKRGが盗まれる危険性があります。" 
                data-lang-en="Access a site where you can view your KRG, such as OpenSea or MetaMask, to confirm its Token ID.
                                <br>＜Warning＞
                                <br>To verify Token IDs, ONLY use URLs from official sources like the KAMITSUBAKI Co-Creation Official Discord. Visiting unofficial sites carries a high risk of fraud, and your KRG could be stolen just by clicking the link."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"

				data-src-jp-dark="picture\step1\KRG_ref_jp_dark.png"
				data-src-jp-light="picture\step1\KRG_ref_jp_light.png"
				data-src-en-dark="picture\step1\KRG_ref_en_dark.png"
				data-src-en-light="picture\step1\KRG_ref_en_light.png"
				
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="b. トークンデータの取得" data-lang-en="b. Fetching Token Data"></h3>
                <p data-lang-jp="トークンIDを半角数字で入力し、[トークンデータ取得] をクリック。
                                <br>GPU負荷を低減したい場合は [軽量モードで取得] をクリック。" 
                   data-lang-en="Enter the Token ID using half-width numbers and click [Fetch Token Data].
                                <br>Click [Lightweight Mode] to reduce GPU load."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"

				data-src-jp-dark="picture\step1\ID_jp_dark.png"
				data-src-jp-light="picture\step1\ID_jp_light.png"
				data-src-en-dark="picture\step1\ID_en_dark.png"
				data-src-en-light="picture\step1\ID_en_light.png"
				
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
            </div>
            
            <div data-help-id="step2" class="hidden">
                <h2 data-lang-jp="Step 2: 切り抜き条件選択" data-lang-en="Step 2: Select Masking Options">Step 2 のヘルプ</h2>
                <p data-lang-jp="このStepでは、切り抜き範囲や切り抜きモードを選択してどの範囲をどのように切り抜くのかを指定できます。" 
                data-lang-en="In this step, you can select the mask area and mask mode to specify which area to mask and how."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step2\area_jp_dark.png"
				data-src-jp-light="picture\step2\area_jp_light.png"
				data-src-en-dark="picture\step2\area_en_dark.png"
				data-src-en-light="picture\step2\area_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="切り抜き範囲の選択" data-lang-en="Select Masking Area"></h3>
                <p data-lang-jp="[頭系]
                <br>人物の頭部に関連するパーツを残して切り抜きます。
                <br><br>[頭系＋体系]
                <br>人物の全身を残して切り抜きます。
                <br><br>[頭系＋体系＋背景系]
                <br>人物の全身と、その後ろに描かれている一部のパーツを残して切り抜きます。
                <br>" 
                data-lang-en="[Head]
                <br>Masks by keeping parts related to the person's head.
                <br><br>[Head + Body]
                <br>Masks by keeping the person's full body.
                <br><br>[Head + Body + Background]
                <br>Masks by keeping the person's full body and some of the parts drawn behind it.
                <br>
                "></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step2\area2_jp_dark.png"
				data-src-jp-light="picture\step2\area2_jp_light.png"
				data-src-en-dark="picture\step2\area2_en_dark.png"
				data-src-en-light="picture\step2\area2_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="切り抜きモードの選択" data-lang-en="Mask Mode Selection"></h3>
                <p data-lang-jp="[切り抜き]
                <br>指定された切り抜き範囲を忠実に透過処理します。一部のパーツは不自然な切り抜かれ方をしますが、補完切り抜きやマニュアル切り抜きで対応できます。"
                data-lang-en="[Masking]
                <br>Faithfully masks the specified area. Some parts may be clipped unnaturally, but this can be addressed with Recovery Masking or Manual Masking.
                "></p>
                <br>
                <p data-lang-jp="[補完切り抜き]
                <br>通常の切り抜き処理に加え、実用性を欠くような切り抜かれ方をされた一部のパーツを補完します。" 
                data-lang-en="[Recovery Masking]
                <br>In addition to the standard masking process, this restores select parts that are clipped in an impractical way.
                "></p>
                <small data-lang-jp="対象パーツ
                <br>・Scarf系
                <br>・Gasmask系" 
                data-lang-en="Target Parts:
                <br>・Scarf series
                <br>・Gasmask series
                "></small>
                <p data-lang-jp="また半透明な色を持つパーツが使用されている場合は、それを模倣したパーツを追加します。" 
                data-lang-en="Additionally, if parts with translucent colors are used, replicated parts will be added to imitate them.
                "></p>
                <small data-lang-jp="対象パーツ
                <br>・Umbrella系
                <br>・IV
                <br>・Face Shiled Black" 
                data-lang-en="Target Parts:
                <br>・Umbrella series
                <br>・IV
                <br>・Face Shiled Black
                "></small>
                <p data-lang-jp="KRGを切り抜く以上の編集を加えるモードです。使用の際は作者へのリスペクトを持って、マナーを守って使用しましょう。" 
                data-lang-en="This mode applies edits beyond just masking the KRG. Please use it with respect for the original artist and with good manners."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step2\IV_jp_dark.png"
				data-src-jp-light="picture\step2\IV_jp_light.png"
				data-src-en-dark="picture\step2\IV_en_dark.png"
				data-src-en-light="picture\step2\IV_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="ヘアノイズ除去" data-lang-en="Stray Hair Fix"></h3>
                <p data-lang-jp="ONにすると、体で切り抜かれて不自然に残った肩から下側の髪の毛を自動で削除します。一部のパーツを使用している一部のKRGにのみ有効です。肩から上の髪の毛はStep3で削除してください。" 
                data-lang-en="When enabled, this automatically removes unnatural hair below the shoulders caused by body masking. This feature is only effective for specific KRGs using certain parts. Please use Step 3 to remove any hair above the shoulders."></p>
            </div>
            <div data-help-id="step3" class="hidden">
                <h2 data-lang-jp="Step 3: マニュアル切り抜き" data-lang-en="Step 3: Manual Masking">Step 3 のヘルプ</h2>
                <p data-lang-jp="このStepでは、不自然な切り抜かれ方をした部分に図形を重ねて、手動で切り抜き処理できます。" 
                data-lang-en="In this step, you can manually mask areas that were clipped unnaturally by overlaying shapes.
                ">このStepでは、不自然な切り抜かれ方をした部分に図形を重ねて、手動で切り抜き処理できます。</p>
                <br>
                <h3 data-lang-jp="a.図形の配置" data-lang-en="a. Placing Shapes"></h3>
                <p data-lang-jp="[図形を配置]ボタンをクリックした後、KRG上の配置したい場所をクリックし、ベースとなる図形を配置します。" 
                data-lang-en="After clicking the [Add Shape] button, click on the KRG canvas where you want to place the shape to add the base shape."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step3\a_jp_dark.png"
				data-src-jp-light="picture\step3\a_jp_light.png"
				data-src-en-dark="picture\step3\a_en_dark.png"
				data-src-en-light="picture\step3\a_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="b.図形を変形" data-lang-en="b. Transforming Shapes"></h3>
                <p data-lang-jp="以下の操作方法で、図形の中に切り抜きたい範囲が収まるようにします。
                <br>・頂点を左クリックしながらドラッグすると、図形を変形できます。
                <br>・辺を右クリックすると頂点の追加ができます。
                <br>・頂点を右クリックすると頂点の削除ができます。" 
                data-lang-en="Use the following operations to fit the area you want to mask inside the shape:
                <br>・You can transform the shape by left-clicking and dragging a vertex.
                <br>・You can add a vertex by right-clicking on an edge.
                <br>・You can delete a vertex by right-clicking on it.
                "></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step3\b2_jp_dark.png"
				data-src-jp-light="picture\step3\b2_jp_light.png"
				data-src-en-dark="picture\step3\b2_en_dark.png"
				data-src-en-light="picture\step3\b2_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
                <br>
                <h3 data-lang-jp="c.切り抜き実行" data-lang-en="c. Applying Masking"></h3>
                <p data-lang-jp="[切り抜き実行]ボタンを押して、図形の範囲を切り抜きます。" 
                data-lang-en="Click the [Apply Masking] button to mask the area defined by the shape(s)."></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step3\c_jp_dark.png"
				data-src-jp-light="picture\step3\c_jp_light.png"
				data-src-en-dark="picture\step3\c_en_dark.png"
				data-src-en-light="picture\step3\c_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
            </div>
            <div data-help-id="step4" class="hidden">
                <h2 data-lang-jp="Step 4: トリミング＆境界ぼかし" data-lang-en="Step 4: Trim & Border Blur">Step 4 のヘルプ</h2>
                <p data-lang-jp="このStepでは、切り抜き画像のトリミングや境界ぼかしを行うことができます。
                <br>各種パラメータを操作して、仕上がりを調整してください。" 
                data-lang-en="In this step, you can trim the masked image or apply a border blur.
                <br>Please adjust the finish by operating the various parameters.
                "></p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step4\step4_jp_dark.png"
				data-src-jp-light="picture\step4\step4_jp_light.png"
				data-src-en-dark="picture\step4\step4_en_dark.png"
				data-src-en-light="picture\step4\step4_en_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
            </div>
            <div data-help-id="step5" class="hidden">
                <h2 data-lang-jp="Step 5: 画像の保存" data-lang-en="Step 5: Save Image">Step 5 のヘルプ</h2>
                <p data-lang-jp="このStepでは、解像度を指定して画像を保存できます。" data-lang-en="In this step, you can specify the resolution to save the image.">（ここにStep5用の説明文をHTMLで書く）</p>
                <img 
				src="" 
				alt="ヘルプ用画像" 
				class="help-content-image dynamic-help-image"
				data-src-jp-dark="picture\step5\sample_jp_dark.png"
				data-src-jp-light="picture\step5\sample_jp_light.png"
				data-src-en-dark="picture\step5\sample_jp_dark.png"
				data-src-en-light="picture\step5\sample_jp_light.png"
				data-lang-alt-jp="ヘルプ用画像"
				data-lang-alt-en="Help Image"
				>
            </div>
            </div>

        </div>
    </div>

    <script>

        const messages = {
            'jp': {
                'tokenIdRequired': 'トークンIDを入力してください。',
                'invalidTokenId': '半角数字で1~4000を入力してください。',
                'fetchingToken': 'トークンデータ取得中...',
                'fetchSuccess': 'データ取得が完了しました。Step2に進んでください。',
                'fetchError': 'エラー: アプリを再起動してください。',
                'maskModeRequired': '切り抜きモードを選択してください。',
                'nftImageRequired': '切り抜き処理にはNFT画像が必要です。',
                'processingMask': '切り抜き実行中...',
                'processingRecoveryMask': '補完切り抜き実行中...',
                'processSuccess': '切り抜きが完了しました。Step3, Step4に進んでください。',
                'processRecoverySuccess': '補完切り抜きが完了しました。Step3, Step4に進んでください。',
                'processError': 'エラー: 切り抜き処理中に問題が発生しました。',
                'modeChange': '切り抜きモード変更中...',
                'strayHairFix': '肩周り補正中...',
                'noImageToSave': '切り抜き処理が完了していません。',
                'manualMaskFirst': '先に切り抜き処理を実行してください。',
                'manualMaskAdd': '図形を配置したい場所をクリックしてください。',
                'manualMaskEdit': '',
                'manualMaskPlaced': '図形を配置しました。頂点を追加＆ドラッグして調整してください。',
                'manualMaskNoShapes': '配置された図形がありません。',
                'manualMaskApplied': 'マニュアル切り抜きを実行しました。',
                'manualMaskUndo': '切り抜き処理を元に戻し、図形を復元しました。',
                'previewOn': 'プレビュー適用: On',
                'previewOff': 'プレビュー適用: Off',
                'addShape': '図形を配置',
                'addShapeOn': '図形を配置'
            },
            'en': {
                'tokenIdRequired': 'Please enter a Token ID.',
                'invalidTokenId': 'Please enter a half-width number between 1 and 4000.',
                'fetchingToken': 'Fetching token data...',
                'fetchSuccess': 'Data fetch complete. Please proceed to Step 2.',
                'fetchError': 'Error: Please restart the app.',
                'maskModeRequired': 'Please select a masking mode.',
                'nftImageRequired': 'NFT Image is required for masking.',
                'processingMask': 'Applying mask...',
                'processingRecoveryMask': 'Applying recovery mask...',
                'processSuccess': 'Masking complete. Please proceed to Step 3 and Step 4.',
                'processRecoverySuccess': 'Recovery masking complete. Please proceed to Step 3 and Step 4.',
                'processError': 'Error: An error occurred during masking.',
                'modeChange': 'Changing masking mode...',
                'strayHairFix': 'Applying shoulder area fix...',
                'noImageToSave': 'Masking is not complete.',
                'manualMaskFirst': 'Please apply masking first.',
                'manualMaskAdd': 'Click on the canvas where you want to place the shape.',
                'manualMaskEdit': '',
                'manualMaskPlaced': 'Shape placed. Add vertices and drag to adjust.',
                'manualMaskNoShapes': 'No shapes have been placed.',
                'manualMaskApplied': 'Manual mask applied.',
                'manualMaskUndo': 'Masking undone and shapes restored.',
                'previewOn': 'Preview: On',
                'previewOff': 'Preview: Off',
                'addShape': 'Add Shape',
                'addShapeOn': 'Placing Shape'
            }
        };

        const getMessage = (key, replacements = {}) => {
            const lang = localStorage.getItem('language') || 'jp'; 
            let message = (messages[lang] && messages[lang][key]) || messages['jp'][key]; 
            for (const placeholder in replacements) {
                message = message.replace(`{${placeholder}}`, replacements[placeholder]);
            }
            return message;
        };

        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3'); 
        const stepManualCut = document.getElementById('stepManualCut'); 
        const stepTrimAndBlur = document.getElementById('stepTrimAndBlur'); 
        const stepCanvasContainer = document.getElementById('stepCanvasContainer'); 
        const fetchDataBtn = document.getElementById('fetchDataBtn');
        const fetchDataLightBtn = document.getElementById('fetchDataLightBtn');
        const saveImageBtn = document.getElementById('saveImageBtn');
        const saveSizeSelect = document.getElementById('saveSizeSelect');
        const tokenIdInput = document.getElementById('tokenIdInput');
        const statusMessage1 = document.getElementById('statusMessage1');
        const statusMessage2 = document.getElementById('statusMessage2');
        const statusMessage3 = document.getElementById('statusMessage3'); 
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');
        const headBtn = document.getElementById('headBtn');
        const headBodyBtn = document.getElementById('headBodyBtn');
        const headBodyBgBtn = document.getElementById('headBodyBgBtn');
        const modeNormalBtn = document.getElementById('modeNormalBtn');
        const modeRecoveryBtn = document.getElementById('modeRecoveryBtn');
        const doPreviewBtn = document.getElementById('doPreviewBtn');
        const doExecuteBtn = document.getElementById('doExecuteBtn');
        const cropTopSlider = document.getElementById('cropTopSlider');
        const cropTopInput = document.getElementById('cropTopInput');
        const cropBottomSlider = document.getElementById('cropBottomSlider');
        const cropBottomInput = document.getElementById('cropBottomInput');
        const cropLeftSlider = document.getElementById('cropLeftSlider');
        const cropLeftInput = document.getElementById('cropLeftInput');
        const cropRightSlider = document.getElementById('cropRightSlider');
        const cropRightInput = document.getElementById('cropRightInput');
        const blurTopSlider = document.getElementById('blurTopSlider');
        const blurTopInput = document.getElementById('blurTopInput');
        const blurBottomSlider = document.getElementById('blurBottomSlider');
        const blurBottomInput = document.getElementById('blurBottomInput');
        const blurLeftSlider = document.getElementById('blurLeftSlider');
        const blurLeftInput = document.getElementById('blurLeftInput');
        const blurRightSlider = document.getElementById('blurRightSlider');
        const blurRightInput = document.getElementById('blurRightInput');
        const valueControlButtons = document.querySelectorAll('.value-control-btn');
        const addShapeBtn = document.getElementById('addShapeBtn');
        const applyManualCutBtn = document.getElementById('applyManualCutBtn');
        const undoShapeEditBtn = document.getElementById('undoShapeEditBtn');
        const redoShapeEditBtn = document.getElementById('redoShapeEditBtn');
        const undoImageCutBtn = document.getElementById('undoImageCutBtn');
        const shapeContextMenu = document.getElementById('shapeContextMenu');
        const ctxAddVertex = document.getElementById('ctxAddVertex');
        const ctxDeleteVertex = document.getElementById('ctxDeleteVertex');
        const ctxDeleteShape = document.getElementById('ctxDeleteShape');
        const ctxCancel = document.getElementById('ctxCancel');
        const toggleAdjustmentsPreviewBtn = document.getElementById('toggleAdjustmentsPreviewBtn');
        let nftImage = null;
        let maskImgs = {};
        let recoveryImgs = {};
        let nftTraits = [];
        let faceMaskImgs = []; 
        let isTransparencyApplied = false;
        let currentMaskingType = 'Mask'; 
        const umbrellaAliases = ["Black Umbrella", "Blue Umbrella", "Red Umbrella", "White Umbrella", "Yellow Umbrella"];
        let currentMode = 'none';
        const cropParams = { top: 0, bottom: 0, left: 0, right: 0 };
        const blurParams = { top: 0, bottom: 0, left: 0, right: 0 };
        let allTokenExceptions = {};
        let currentTokenException = null; 
        let blueLightningExceptionImg = null;
        let blueLightningHandImg = null; 
        let flameExceptionImg = null;
        let flameHandImg = null;       
        const strayHairControl = document.getElementById('strayHairControl');
        const strayHairFixOnBtn = document.getElementById('strayHairFixOnBtn');
        const strayHairFixOffBtn = document.getElementById('strayHairFixOffBtn');
        let isStrayHairFixOn = false;
        let underHairFixMasks = {}; 
        const CANVAS_PADDING_RATIO = 0.125; 
        let shapes = []; 
        let isAddingShapeMode = false; 
        let draggingVertex = null; 
        let draggingShape = null; 
        let hoveredVertex = null; 
        let hoveredEdge = null; 
        let editHistory = [];     // { image: Canvas, shapes: Array } の配列
        let currentHistoryIndex = -1;
        const MAX_HISTORY_LENGTH = 50; // 図形編集も含めるため、少し多めに
        let contextMenu = { visible: false, x: 0, y: 0, target: null }; 
        const VERTEX_DRAW_SIZE = 5; 
        const VERTEX_HIT_BUFFER = 3; 
        const LINE_HIT_WIDTH = 10; 
        let isAdjustmentsPreviewOn = true; 
        let IVExceptionImg = null; 
        let isIVException = false;

        // UI判定用フラグ変数
        let hasRecoveryLayers = false;          // 補完レイヤーが存在するか
        let isSpecialRecoveryException = false; // 特殊な補完例外 (FaceShield/Umbrella) か
        let hasBgLayer = false;                 // 背景レイヤー(bp_layer1)が存在するか
        let isFaceShieldBlackException = false; // Face Shield Blackを持っているか 
        let isUmbrellaException = false;        // Umbrella系を持っているか
        
        function hexToRgba(hex, alpha = 1) {
            if (!hex || hex.charAt(0) !== '#') {
                if (hex === '#000000' || hex.toLowerCase() === 'black') {
                    return `rgba(0, 0, 0, ${alpha})`;
                }
                if (hex === '#FFFFFF' || hex.toLowerCase() === 'white') {
                    return `rgba(255, 255, 255, ${alpha})`;
                }
                return hex; 
            }

            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        const loadImage = (url) => new Promise((res, rej) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => res(img);
            img.onerror = () => {
                console.error(`画像 ${url} のロードに失敗`);
                res({ width: 0, height: 0, src: url });
            };
            img.src = url;
        });
        
        function cloneCanvas(oldCanvas) {
            const newCanvas = document.createElement('canvas');
            const newCtx = newCanvas.getContext('2d');
            newCanvas.width = oldCanvas.width;
            newCanvas.height = oldCanvas.height;
            newCtx.drawImage(oldCanvas, 0, 0);
            return newCanvas;
        }
        
        // ボタンクリックイベント設定
        fetchDataBtn.addEventListener('click', () => executeFetchProcess(false));      // 通常モード (isLightMode = false)
        fetchDataLightBtn.addEventListener('click', () => executeFetchProcess(true));  // 軽量モード (isLightMode = true)

        // 共通処理関数
        async function executeFetchProcess(isLightMode) {
            const tokenId = tokenIdInput.value;
            const tokenIdNum = Number(tokenId);
            const isValid = Number.isInteger(tokenIdNum) && tokenIdNum >= 1 && tokenIdNum <= 5000;
 
            if (!isValid) {
                statusMessage1.textContent = getMessage('invalidTokenId');
                statusMessage1.dataset.langKey = 'invalidTokenId';
                statusMessage1.dataset.langVars = '{}';
                return;
            }

            statusMessage1.textContent = getMessage('fetchingToken');
            statusMessage1.dataset.langKey = 'fetchingToken';
            statusMessage1.dataset.langVars = '{}';
            statusMessage1.classList.add('loading');

            // UIリセット処理
            step2.classList.add('hidden');
            stepManualCut.classList.add('hidden'); 
            stepTrimAndBlur.classList.add('hidden'); 
            step3.classList.add('hidden');
            stepCanvasContainer.classList.add('hidden');
            
            hasRecoveryLayers = false;
            isSpecialRecoveryException = false;
            maskImgs = {};
            recoveryImgs = {};
            nftTraits = [];
            faceMaskImgs = []; 
            isTransparencyApplied = false;
            currentTokenException = null; 
            blueLightningExceptionImg = null; 
            blueLightningHandImg = null; 
            flameExceptionImg = null; 
            flameHandImg = null;
            IVExceptionImg = null;
            isStrayHairFixOn = false;
            strayHairFixOffBtn.classList.add('active');
            strayHairFixOnBtn.classList.remove('active');
            strayHairControl.classList.add('hidden');
            underHairFixMasks = {};
            shapes = [];
            isAddingShapeMode = false;
            draggingVertex = null;
            draggingShape = null;
            hoveredVertex = null;
            hoveredEdge = null;
            editHistory = [];
            currentHistoryIndex = -1;
            contextMenu.visible = false;
            isAdjustmentsPreviewOn = true; 
            toggleAdjustmentsPreviewBtn.classList.add('active');
            toggleAdjustmentsPreviewBtn.textContent = getMessage('previewOn');
            addShapeBtn.textContent = getMessage('addShape');
            updateCutModeUI(); 
            currentMode = 'none';
            headBtn.classList.remove('active');
            headBodyBtn.classList.remove('active');
            headBodyBgBtn.classList.remove('active');
            Object.keys(cropParams).forEach(key => cropParams[key] = 0);
            Object.keys(blurParams).forEach(key => blurParams[key] = 0);
            updateCropUI(0, 0, 0, 0);
            updateBlurUI(0, 0, 0, 0);

            try {
                // --- 1. 例外・Traits・画像のフェッチ ---
                try {
                    const exceptionResponse = await fetch('/api/get-token-exceptions');
                    if (exceptionResponse.ok) {
                        allTokenExceptions = await exceptionResponse.json();
                    } else {
                        allTokenExceptions = {};
                    }
                } catch (exErr) {
                    allTokenExceptions = {};
                }

                const traitsResponse = await fetch(`/api/get-traits?tokenId=${encodeURIComponent(tokenId)}`);
                const traitsData = await traitsResponse.json();
                nftTraits = traitsData.traits;

                if (allTokenExceptions[tokenId]) {
                    currentTokenException = allTokenExceptions[tokenId];
                    console.log(`★トークンID ${tokenId} 固有の例外ルールを適用します:`, currentTokenException);
                }

                if (currentTokenException) {
                    const exceptionsList = Array.isArray(currentTokenException) ? currentTokenException : [currentTokenException];
                    exceptionsList.forEach(ex => {
                        if (ex.type === 'FORCE_TRAIT') {
                            nftTraits.push({ trait_type: ex.trait_type, value: ex.value });
                        }
                    });
                }

                isIVException = nftTraits.some(trait => trait.trait_type === 'Backparts 01' && trait.value === 'IV');
                isFaceShieldBlackException = nftTraits.some(trait => trait.trait_type === 'Face Accessories' && trait.value === 'Face Shiled Black');
                const umbrellaAliases = ["Black Umbrella", "Blue Umbrella", "Red Umbrella", "White Umbrella", "Yellow Umbrella"];
                isUmbrellaException = nftTraits.some(trait => trait.trait_type === 'Hand' && umbrellaAliases.includes(trait.value));
                isSpecialRecoveryException = isFaceShieldBlackException || isUmbrellaException;

                const maskUrlsResponse = await fetch(`/api/get-masks-by-layers?tokenId=${encodeURIComponent(tokenId)}&traits=${encodeURIComponent(JSON.stringify(traitsData.traits))}`);
                if (!maskUrlsResponse.ok) throw new Error(`マスク画像の検索に失敗しました。`);
                const maskUrlsData = await maskUrlsResponse.json();
                const maskUrlsByLayer = maskUrlsData.maskUrlsByLayer;
                const faceMaskUrls = maskUrlsData.faceMaskUrls || [];
                
                const recoveryUrlsResponse = await fetch(`/api/get-recovery-masks-by-layers?tokenId=${encodeURIComponent(tokenId)}&traits=${encodeURIComponent(JSON.stringify(traitsData.traits))}`);
                if (!recoveryUrlsResponse.ok) throw new Error(`補完画像の検索に失敗しました。`);
                const recoveryUrlsData = await recoveryUrlsResponse.json();
                const recoveryUrlsByLayer = recoveryUrlsData.maskUrlsByLayer;

                const imageResponse = await fetch(`/api/get-image?tokenId=${encodeURIComponent(tokenId)}`);
                if (!imageResponse.ok) throw new Error(`NFT画像の取得に失敗しました。`);
                const imageData = await imageResponse.json();
                const proxiedImageUrl = `/api/proxy-image?url=${encodeURIComponent(imageData.imageUrl)}`;
                
                const loadFaceMasksPromise = Promise.all(faceMaskUrls.map(url => new Promise((res, rej) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => res(img);
                    img.onerror = rej;
                    img.src = url;
                })));

                // エフェクト例外などのロード
                const blueLightningAliases = ["Blue Lightning", "Blue Lightning Blue Skin", "Blue Lightning Red Skin"];
                const isBlueLightningException = nftTraits.some(trait => trait.trait_type === 'Hand' && blueLightningAliases.includes(trait.value));
                const flameAliases = ["Flame", "Flame Blue Skin", "Flame Red Skin"];
                const isFlameException = nftTraits.some(trait => trait.trait_type === 'Hand' && flameAliases.includes(trait.value));
                
                let loadExceptionPromises = []; 
                const loadExceptionImage = (url, name) => {
                    return new Promise((res) => { 
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        img.onload = () => res(img);
                        img.onerror = () => res(null); 
                        img.src = url;
                    });
                };

                if (isBlueLightningException) {
                    loadExceptionPromises.push(loadExceptionImage('/assets/Exception/head_layer3_Blue_Lightning.png', 'Blue Lightning').then(img => { blueLightningExceptionImg = img; }));
                    loadExceptionPromises.push(loadExceptionImage('/assets/Exception/body_layer3_Blue_Lightning_hand.png', 'Blue Lightning Hand').then(img => { blueLightningHandImg = img; }));
                }
                if (isFlameException) {
                    loadExceptionPromises.push(loadExceptionImage('/assets/Exception/head_layer3_Flame.png', 'Flame').then(img => { flameExceptionImg = img; }));
                    loadExceptionPromises.push(loadExceptionImage('/assets/Exception/body_layer3_Flame_hand.png', 'Flame Hand').then(img => { flameHandImg = img; }));
                }
                if (isIVException) {
                    loadExceptionPromises.push(loadExceptionImage('/assets/Exception/IV.png', 'IV').then(img => { IVExceptionImg = img; }));
                }

                await Promise.all([
                    loadAllImages(maskUrlsByLayer, proxiedImageUrl, recoveryUrlsByLayer),
                    loadFaceMasksPromise.then(images => { faceMaskImgs = images; }),
                    ...loadExceptionPromises 
                ]);


                // --- 2. キャンバスサイズ設定 (通常 vs 軽量モード) ---
                // ▼▼▼ 保存サイズ選択肢の制御 (軽量モードなら16Kを隠す) ▼▼▼
                const option16k = saveSizeSelect.querySelector('option[value="16384"]');
                if (isLightMode) {
                    // 軽量モード: 16384pxを選択できないようにする
                    if (option16k) {
                        option16k.style.display = 'none';
                        option16k.disabled = true;   
                    }
                    // もし16Kが選択されていたら、自動的に4Kに変更する
                    if (saveSizeSelect.value === '16384') {
                        saveSizeSelect.value = '3840';
                    }
                } else {
                    // 通常モード: 16384pxを選択可能にする
                    if (option16k) {
                        option16k.style.display = '';     // 表示
                        option16k.disabled = false;       // 有効化
                    }
                    // 通常モードはデフォルトで16Kを選択しておく
                    saveSizeSelect.value = '16384';
                }

                const largestMask = getLargestMask(maskImgs);
                let width = largestMask ? largestMask.width : nftImage.width;
                let height = largestMask ? largestMask.height : nftImage.height;

                if (isLightMode) {
                    const TARGET_SIZE = 3840;

                    // 元画像の幅が4Kより大きい場合のみ縮小
                    if (width > TARGET_SIZE) {
                        const aspect = height / width;
                        width = TARGET_SIZE;
                        height = Math.round(TARGET_SIZE * aspect);
                        
                        console.log(`★ 軽量モード: キャンバスサイズを縮小しました (${largestMask ? largestMask.width : nftImage.width} -> ${width}x${height})`);
                        
                        // 補足: FaceShieldBlackなどの座標計算は 'canvasWidth' (このwidth) に基づく相対計算になっているため、ここで width を変更すれば自動的に整合します。
                    }
                } else {
                    console.log(`★ 通常モード: オリジナル解像度を使用します (${width}x${height})`);
                }

                // オフスクリーンキャンバス(処理用)のサイズ確定
                offscreenCanvas.width = width;
                offscreenCanvas.height = height;

                // プレビュー用キャンバスのサイズ計算 (メモリ対策 + 余白追加)
                const MAX_PREVIEW_WIDTH = 2560; 
                let previewBaseWidth = width;
                let previewBaseHeight = height;

                if (width > MAX_PREVIEW_WIDTH) {
                    const scale = MAX_PREVIEW_WIDTH / width;
                    previewBaseWidth = MAX_PREVIEW_WIDTH;
                    previewBaseHeight = height * scale;
                }

                const paddingW = previewBaseWidth * CANVAS_PADDING_RATIO;
                const paddingH = previewBaseHeight * CANVAS_PADDING_RATIO;
                
                previewCanvas.width = previewBaseWidth + (paddingW * 2);
                previewCanvas.height = previewBaseHeight + (paddingH * 2);
                
                // --- 3. 以降のUI更新処理 (既存コードと同様) ---

                hasBgLayer = (maskImgs.bp_layer1 && maskImgs.bp_layer1.length > 0);
                // 特殊例外フラグは上で更新済み

                hasRecoveryLayers = false;
                for (const layer in recoveryImgs) {
                    if (layer.startsWith('recovery_layer') && recoveryImgs[layer] && recoveryImgs[layer].length > 0) {
                        hasRecoveryLayers = true;
                        break;
                    }
                }
                
                // UnderHair Fix 読み込み
                const fixMaskPromises = [];
                const baseNamesToLoad = new Set(); 
                const sourcesToScan = [{ obj: maskImgs, pathPart: '/assets/Under Hair/' }, { obj: recoveryImgs, pathPart: '/assets/recovery_assets/Under Hair/' }];
                sourcesToScan.forEach(source => {
                    for (const layer in source.obj) {
                        if (source.obj[layer]) source.obj[layer].forEach(img => {
                                if (!img || !img.src) return; 
                                const decodedSrc = decodeURIComponent(img.src);
                                if (decodedSrc && decodedSrc.includes(source.pathPart)) {
                                    const fileName = img.src.split('/').pop();
                                    const match = fileName.match(/^(?:.*_layer\d+_)?(.*)\.png$/i);
                                    if (match && match[1]) baseNamesToLoad.add(match[1]);
                                }
                        });
                    }
                });
                baseNamesToLoad.forEach(baseName => {
                    fixMaskPromises.push(loadImage(`/assets/Fix_Under_Hair/Fix_${baseName}.png`).then(fixImg => {
                        if (fixImg && fixImg.width > 0) underHairFixMasks[baseName] = fixImg;
                    }));
                });
                await Promise.all(fixMaskPromises);
                
                // ADD_MASK 処理 (配列対応)
                const addMaskExceptions = Array.isArray(currentTokenException) ? currentTokenException : (currentTokenException ? [currentTokenException] : []);
                for (const ex of addMaskExceptions) {
                    if (ex.type === 'ADD_MASK') {
                        try {
                            const exceptionMaskImg = await loadExceptionImage(ex.url, 'ADD_MASK');
                            if (exceptionMaskImg && exceptionMaskImg.width > 0) {
                                if (!maskImgs[ex.layer]) maskImgs[ex.layer] = [];
                                maskImgs[ex.layer].push(exceptionMaskImg);
                                if (ex.purpose === 'face_clipping') faceMaskImgs.push(exceptionMaskImg);
                            }
                        } catch (e) { console.error(e); }
                    }
                }

                // Powersuit Neck などの加工処理 (キャンバスサイズに依存するため offscreenCanvas.width 等を使用するが、
                // getLargestMaskは元の画像サイズを返すため注意が必要。 
                // --- 重要: 合成用の一時キャンバスはすべて offscreenCanvas.width (現在のモードのサイズ) に合わせる ---
                const currentW = offscreenCanvas.width;
                const currentH = offscreenCanvas.height;

                if (maskImgs.body_layer1 && maskImgs.body_layer1.length > 0 && faceMaskImgs.length > 0) {
                    const clothesCanvas = document.createElement('canvas');
                    const clothesCtx = clothesCanvas.getContext('2d');
                    clothesCanvas.width = currentW;
                    clothesCanvas.height = currentH;
                    maskImgs.body_layer1.forEach(img => { clothesCtx.drawImage(img, 0, 0, currentW, currentH); });
                    clothesCtx.globalCompositeOperation = 'destination-out';
                    faceMaskImgs.forEach(img => { clothesCtx.drawImage(img, 0, 0, currentW, currentH); });
                    clothesCtx.globalCompositeOperation = 'source-over';
                    maskImgs.body_layer1 = [clothesCanvas]; 
                }

                if (maskImgs.body_layer2 && maskImgs.body_layer2.length > 0 && faceMaskImgs.length > 0) {
                    const powersuitNeckImages = maskImgs.body_layer2.filter(img => img.src && decodeURIComponent(img.src).includes('Powersuit_Neck'));
                    if (powersuitNeckImages.length > 0) {
                         maskImgs.body_layer2 = maskImgs.body_layer2.map(img => {
                             if (img.src && decodeURIComponent(img.src).includes('Powersuit_Neck')) {
                                 const canvas = document.createElement('canvas');
                                 canvas.width = currentW;
                                 canvas.height = currentH;
                                 const ctx = canvas.getContext('2d');
                                 ctx.drawImage(img, 0, 0, currentW, currentH);
                                 ctx.globalCompositeOperation = 'destination-out';
                                 faceMaskImgs.forEach(faceImg => { ctx.drawImage(faceImg, 0, 0, currentW, currentH); });
                                 ctx.globalCompositeOperation = 'source-over';
                                 return canvas; 
                             }
                             return img; 
                         });
                    }
                }
                
                updatePreview();
                step2.classList.remove('hidden');
                step2.classList.add('slide-in');
                stepCanvasContainer.classList.remove('hidden'); 
                stepCanvasContainer.classList.add('slide-in'); 
                
                statusMessage1.textContent = getMessage('fetchSuccess');
                statusMessage1.dataset.langKey = 'fetchSuccess';
                statusMessage1.dataset.langVars = '{}';
                statusMessage1.classList.remove('loading');
                
                handleModeChange(currentMode, document.getElementById(currentMode + 'Btn'));

            } catch (error) {
                console.error('Fetch error:', error);
                const vars = { errorMessage: error.message };
                statusMessage1.textContent = getMessage('fetchError', vars);
                statusMessage1.dataset.langKey = 'fetchError';
                statusMessage1.dataset.langVars = JSON.stringify(vars);
                statusMessage1.classList.remove('loading');
            }
        }

        async function loadAllImages(maskUrlsByLayer, nftImageUrl, recoveryUrlsByLayer = {}) {
            
            const loadLayerImages = async (urlsByLayer, targetObject) => {
                const allPromises = [];
                for (const layer in urlsByLayer) {
                    urlsByLayer[layer].forEach(url => {
                        allPromises.push(
                            loadImage(url).then(img => ({ img, layer }))
                        );
                    });
                }
                const loadedImages = await Promise.all(allPromises);
                loadedImages.forEach(({ img, layer }) => {
                    if (img.width > 0) {
                        if (!targetObject[layer]) targetObject[layer] = [];
                        targetObject[layer].push(img);
                    }
                });
            };

            const loadNftImagePromise = new Promise((resolve, reject) => {
                nftImage = new Image();
                nftImage.crossOrigin = 'anonymous';
                nftImage.onload = () => resolve();
                nftImage.onerror = () => reject(new Error(`NFT画像 ${nftImageUrl} のロードに失敗`));
                nftImage.src = nftImageUrl;
            });
            
            maskImgs = {};
            recoveryImgs = {};
            await Promise.all([
                loadLayerImages(maskUrlsByLayer, maskImgs),
                loadLayerImages(recoveryUrlsByLayer, recoveryImgs),
                loadNftImagePromise
            ]);

            const recoverySrcs = {};
            for (const layer in recoveryImgs) {
                recoverySrcs[layer] = recoveryImgs[layer].map(img => img.src);
            }
            console.log("★ Recovery: 補完画像(recoveryImgs)の読み込み結果 (srcリスト):", recoverySrcs);
        }

        function getLargestMask(maskObject) {
            let largest = null;
            for (const layer in maskObject) {
                if (Array.isArray(maskObject[layer])) {
                    maskObject[layer].forEach(mask => {
                        if (mask && (!largest || (mask.width * mask.height) > (largest.width * largest.height))) {
                            largest = mask;
                        }
                    });
                }
            }
            return largest;
        }

        function getActiveMasks(mode, isRecovery = null) {
            const activeMasks = {};
            for (const layer in maskImgs) {
                if (Array.isArray(maskImgs[layer])) {
                    activeMasks[layer] = [...maskImgs[layer]]; 
                }
            }

            const shouldFixStrayHair = mode === 'head' && isStrayHairFixOn && Object.keys(underHairFixMasks).length > 0;
            
            if (isRecovery === null) { 
                 console.log(`★ UnderHair Fix (getActiveMasks / maskImgs): 適用条件チェック (isRecovery: ${isRecovery}): 
    - mode === 'head': ${mode === 'head'}
    - isStrayHairFixOn: ${isStrayHairFixOn}
    - masks loaded > 0: ${Object.keys(underHairFixMasks).length > 0}
    - >> 最終結果: ${shouldFixStrayHair}`);
            }

            if (shouldFixStrayHair) {
                if (isRecovery === null) {
                    console.log(`★ UnderHair Fix (getActiveMasks / maskImgs): 適用処理を実行します...`);
                }
                
                const canvasWidth = offscreenCanvas.width;
                const canvasHeight = offscreenCanvas.height;

                for (const layer in activeMasks) {
                    if (Array.isArray(activeMasks[layer])) {
                        activeMasks[layer] = activeMasks[layer].map(originalImg => {
                            if (!originalImg || !originalImg.src) {
                                return originalImg;
                            }

                            const fileName = originalImg.src.split('/').pop();
                            const match = fileName.match(/^(?:.*_layer\d+_)?(.*)\.png$/i);
                            let fixMask = null;
                            let baseName = null;

                            if (match && match[1]) {
                                baseName = match[1];
                                fixMask = underHairFixMasks[baseName];
                            }
                            
                            if (fixMask) {
                                if (isRecovery === null) { 
                                    console.log(`★ UnderHair Fix (getActiveMasks): [実行] 補正マスク ${fixMask.src} (key: ${baseName}) を使って、元画像 ${originalImg.src} をくり抜きます。`);
                                }
                                
                                const tempCanvas = document.createElement('canvas');
                                tempCanvas.width = canvasWidth;
                                tempCanvas.height = canvasHeight;
                                const tempCtx = tempCanvas.getContext('2d');

                                tempCtx.drawImage(originalImg, 0, 0, canvasWidth, canvasHeight);
                                tempCtx.globalCompositeOperation = 'destination-out';
                                tempCtx.drawImage(fixMask, 0, 0, canvasWidth, canvasHeight);
                                tempCtx.globalCompositeOperation = 'source-over';
                                
                                return tempCanvas; 
                            } else {
                                const decodedSrc = decodeURIComponent(originalImg.src);
                                if (decodedSrc && decodedSrc.includes('/assets/Under Hair/')) {
                                    if (isRecovery === null) { 
                                        console.log(`★ UnderHair Fix (getActiveMasks): [スキップ] ${originalImg.src} (base: ${baseName}) はUnderHair画像ですが、対応する補正マスクが見つかりませんでした。`);
                                    }
                                }
                                return originalImg;
                            }
                        });
                    }
                }
            }

            if (mode === 'head' && blueLightningExceptionImg) {
                console.log(`★ Blue Lightning 例外: '${mode}' モードで適用します。`);

                let originalMaskRemoved = false;
                if (activeMasks.body_layer3) {
                    activeMasks.body_layer3 = activeMasks.body_layer3.filter(img => {
                        const isLightning = img.src && img.src.includes('Blue_Lightning'); 
                        if (isLightning) {
                            console.log(`★ Blue Lightning 例外: body_layer3 から original マスク (${img.src}) を削除。`);
                            originalMaskRemoved = true;
                        }
                        return !isLightning;
                    });
                }

                if (originalMaskRemoved) {
                    if (!activeMasks.head_layer3) activeMasks.head_layer3 = [];
                    activeMasks.head_layer3.push(blueLightningExceptionImg);
                    console.log(`★ Blue Lightning 例外: head_layer3 にエフェクト (${blueLightningExceptionImg.src}) を追加。`);
                    if (blueLightningHandImg) {
                        if (!activeMasks.body_layer3) activeMasks.body_layer3 = [];
                        activeMasks.body_layer3.push(blueLightningHandImg);
                        console.log(`★ Blue Lightning 例外: body_layer3 にハンド (${blueLightningHandImg.src}) を追加 (マスク用)。`);
                    }

                } else if (blueLightningExceptionImg) {
                    console.warn("★ Blue Lightning 例外: body_layer3 に original マスクが見つかりませんでした。");
                }
            }
            
            if (mode === 'head' && flameExceptionImg) {
                console.log(`★ Flame 例外: '${mode}' モードで適用します。`);
                
                let originalMaskRemoved = false;
                if (activeMasks.body_layer3) {
                    activeMasks.body_layer3 = activeMasks.body_layer3.filter(img => {
                        const isFlame = img.src && img.src.includes('Flame'); 
                        if (isFlame) {
                            if (!img.src.includes('Blue_Lightning')) {
                                console.log(`★ Flame 例外: body_layer3 から original マスク (${img.src}) を削除。`);
                                originalMaskRemoved = true;
                                return false; 
                            }
                        }
                        return true; 
                    });
                }

                if (originalMaskRemoved) {
                    if (!activeMasks.head_layer3) activeMasks.head_layer3 = [];
                    activeMasks.head_layer3.push(flameExceptionImg);
                    console.log(`★ Flame 例外: head_layer3 にエフェクト (${flameExceptionImg.src}) を追加。`);

                    if (flameHandImg) {
                        if (!activeMasks.body_layer3) activeMasks.body_layer3 = [];
                        activeMasks.body_layer3.push(flameHandImg);
                        console.log(`★ Flame 例外: body_layer3 にハンド (${flameHandImg.src}) を追加 (マスク用)。`);
                    }

                } else if (flameExceptionImg) {
                    console.warn("★ Flame 例外: body_layer3 に original マスクが見つかりませんでした。");
                }
            }
            
            return activeMasks;
        }

        // ▼▼▼  座標変換ヘルパー関数 ▼▼▼
        function getCoordinateParams() {
            if (!previewCanvas || !offscreenCanvas) return null;
            
            // プレビューキャンバスの全幅・全高
            const totalW = previewCanvas.width;
            const totalH = previewCanvas.height;
            
            // その中の「画像エリア」のサイズ
            const imgAreaW = totalW / (1 + CANVAS_PADDING_RATIO * 2);
            const imgAreaH = totalH / (1 + CANVAS_PADDING_RATIO * 2);
            
            // オフセット量
            const offsetX = (totalW - imgAreaW) / 2;
            const offsetY = (totalH - imgAreaH) / 2;
            
            // 元画像(offscreen) -> プレビュー画像エリア(imgArea) への縮小率
            const scale = imgAreaW / offscreenCanvas.width;
            
            return { offsetX, offsetY, scale };
        }

        function getInternalCoords(event) {
            if (!previewCanvas || !offscreenCanvas) return { x: 0, y: 0 };
            const rect = previewCanvas.getBoundingClientRect();
            if (rect.width === 0) return { x: 0, y: 0 };
            
            // 1. プレビューキャンバス内の画素位置
            const scaleDisplay = previewCanvas.width / rect.width;
            const clientX = event.clientX ?? (event.touches?.[0]?.clientX ?? 0);
            const clientY = event.clientY ?? (event.touches?.[0]?.clientY ?? 0);
            const rawX = (clientX - rect.left) * scaleDisplay;
            const rawY = (clientY - rect.top) * scaleDisplay;
            
            // 2. 元画像座標
            const params = getCoordinateParams();
            if (!params) return { x: 0, y: 0 };
            
            // オフセットを引いて、スケールで割る (これで画像外の座標も扱える)
            const x = (rawX - params.offsetX) / params.scale;
            const y = (rawY - params.offsetY) / params.scale;
            
            return { x, y };
        }

        function getDisplayCoords(internalX, internalY) {
            return { x: 0, y: 0 }; 
        }

        // 履歴を初期化する (モード変更時や初期ロード時)
        function initHistory() {
            editHistory = [];
            currentHistoryIndex = -1;
            recordHistory(); // 現在の状態(初期状態)を記録
        }

        // 現在の状態を履歴に追加する
        // forceNewImage: 透過処理など、画像自体が変わった場合は true にする
        function recordHistory(forceNewImage = false) {
            // 1. 未来の履歴(Redo分)を削除
            if (currentHistoryIndex < editHistory.length - 1) {
                editHistory = editHistory.slice(0, currentHistoryIndex + 1);
            }

            // 2. 保存する画像データの決定
            // メモリ節約のため、画像に変更がない(図形編集のみ)場合は、直前の履歴と同じ画像を参照させる
            let imageToSave;
            if (editHistory.length > 0 && !forceNewImage && currentHistoryIndex >= 0) {
                // 画像変更なし -> 前の画像を使い回す
                imageToSave = editHistory[currentHistoryIndex].image;
            } else {
                // 画像変更あり(初回含む) -> 複製を作成
                imageToSave = cloneCanvas(offscreenCanvas);
            }

            // 3. 履歴オブジェクトの作成
            const state = {
                image: imageToSave,
                shapes: JSON.parse(JSON.stringify(shapes)) // 図形は常にディープコピー
            };

            // 4. スタックに追加
            editHistory.push(state);
            currentHistoryIndex++;

            // 5. 制限を超えたら古いものを削除
            if (editHistory.length > MAX_HISTORY_LENGTH) {
                editHistory.shift();
                currentHistoryIndex--;
            }

            updateHistoryButtons();
        }

        // 履歴ボタンの表示更新
        function updateHistoryButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            // ボタンが存在しない場合のエラー回避
            if (undoBtn) undoBtn.disabled = (currentHistoryIndex <= 0);
            if (redoBtn) redoBtn.disabled = (currentHistoryIndex >= editHistory.length - 1);
            
            applyManualCutBtn.disabled = (shapes.length === 0);
        }

        function updateCutModeUI() {
            if (isTransparencyApplied) {
                previewCanvas.classList.add('cut-active');
            } else {
                previewCanvas.classList.remove('cut-active');
                previewCanvas.classList.remove('grabbing');
                previewCanvas.classList.remove('pointer');
                previewCanvas.classList.remove('adding');
                statusMessage3.textContent = '';
                isAddingShapeMode = false;
            }

            if (isAddingShapeMode) {
                addShapeBtn.classList.add('active');
                addShapeBtn.textContent = getMessage('addShapeOn');
            } else {
                addShapeBtn.classList.remove('active');
                addShapeBtn.textContent = getMessage('addShape');
            }
            
            updateHistoryButtons();
        }

        // Undo (元に戻す)
        function executeUndo() {
            if (currentHistoryIndex <= 0) return;

            currentHistoryIndex--;
            restoreState(editHistory[currentHistoryIndex]);
        }

        // Redo (やり直す)
        function executeRedo() {
            if (currentHistoryIndex >= editHistory.length - 1) return;

            currentHistoryIndex++;
            restoreState(editHistory[currentHistoryIndex]);
        }

        // 指定した履歴状態を復元する
        function restoreState(state) {
            // 1. 画像を復元
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCtx.drawImage(state.image, 0, 0);

            // 2. 図形を復元
            shapes = JSON.parse(JSON.stringify(state.shapes));
            
            updatePreview();
            updateHistoryButtons();
        }

        function drawShapes() {
            if (!previewCtx || shapes.length === 0) return;
            
            const params = getCoordinateParams();
            if (!params) return;
            
            // 線の太さ調整
            const rect = previewCanvas.getBoundingClientRect();
            const scaleDisplay = previewCanvas.width / rect.width;
            const drawLineWidth = 1 * scaleDisplay;
            const drawVertexRadius = VERTEX_DRAW_SIZE * scaleDisplay;

            previewCtx.save();

            shapes.forEach(shape => {
                const { vertices } = shape;
                if (vertices.length === 0) return;

                previewCtx.beginPath();
                
                // 座標変換: (x * scale) + offset
                const tx = (v) => v.x * params.scale + params.offsetX;
                const ty = (v) => v.y * params.scale + params.offsetY;

                previewCtx.moveTo(tx(vertices[0]), ty(vertices[0]));
                for (let i = 1; i < vertices.length; i++) {
                    previewCtx.lineTo(tx(vertices[i]), ty(vertices[i]));
                }
                previewCtx.closePath();
                
                previewCtx.strokeStyle = 'rgba(231, 76, 60, 0.9)';
                previewCtx.lineWidth = drawLineWidth;
                previewCtx.stroke();

                vertices.forEach((vertex) => {
                    previewCtx.fillStyle = '#34495e';
                    previewCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    previewCtx.lineWidth = drawLineWidth;
                    
                    previewCtx.beginPath();
                    const vx = tx(vertex);
                    const vy = ty(vertex);

                    previewCtx.rect(
                        vx - drawVertexRadius, 
                        vy - drawVertexRadius, 
                        drawVertexRadius * 2, 
                        drawVertexRadius * 2
                    );
                    previewCtx.fill();
                    previewCtx.stroke();
                });
            });
            previewCtx.restore();
        }
        
        function distToSegmentSquaredInternal(p, v, w) {
            const l2 = (p1, p2) => Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
            const segmentLengthSq = l2(v, w);
            if (segmentLengthSq === 0) return l2(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / segmentLengthSq;
            t = Math.max(0, Math.min(1, t)); 
            const closestPoint = {
                x: v.x + t * (w.x - v.x),
                y: v.y + t * (w.y - v.y)
            };
            return l2(p, closestPoint);
        }

        function updateHoverState(event) {
            if (!isTransparencyApplied || draggingVertex || draggingShape || isAddingShapeMode) {
                previewCanvas.classList.remove('pointer');
                return;
            }

            const internalCoords = getInternalCoords(event);
            const rect = previewCanvas.getBoundingClientRect();
            if (rect.width === 0 || offscreenCanvas.width === 0) return;
            const scale = offscreenCanvas.width / rect.width; 
            const vertexHitRadiusSq = Math.pow((VERTEX_DRAW_SIZE + VERTEX_HIT_BUFFER) * scale, 2);
            const lineHitRadiusSq = Math.pow(LINE_HIT_WIDTH * scale, 2); 
            let newHoveredVertex = null;
            let newHoveredEdge = null;
            let minVertexDistSq = vertexHitRadiusSq; 
            let minEdgeDistSq = lineHitRadiusSq; 

            for (const shape of shapes) {
                const { id, vertices } = shape;
                
                // 頂点のホバーチェック (内部座標系)
                for (let i = 0; i < vertices.length; i++) {
                    const v = vertices[i];
                    const distSq = Math.pow(internalCoords.x - v.x, 2) + Math.pow(internalCoords.y - v.y, 2);
                    if (distSq < minVertexDistSq) {
                        minVertexDistSq = distSq;
                        newHoveredVertex = { shapeId: id, vertexIndex: i };
                    }
                }

                // 辺のホバーチェック (内部座標系)
                if (!newHoveredVertex) { 
                    for (let i = 0; i < vertices.length; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % vertices.length];
                        
                        const distSq = distToSegmentSquaredInternal(internalCoords, v1, v2);

                        if (distSq < minEdgeDistSq) {
                            minEdgeDistSq = distSq;
                            newHoveredEdge = { shapeId: id, vertexIndex1: i, vertexIndex2: (i + 1) % vertices.length };
                        }
                    }
                }
            }

            // カーソルと状態の更新
            if (newHoveredVertex) {
                hoveredVertex = newHoveredVertex;
                hoveredEdge = null;
                previewCanvas.classList.add('pointer');
            } else if (newHoveredEdge) {
                hoveredVertex = null;
                hoveredEdge = newHoveredEdge;
                previewCanvas.classList.add('pointer'); 
            } else {
                hoveredVertex = null;
                hoveredEdge = null;
                previewCanvas.classList.remove('pointer');
            }
        }

        function updatePreview() {
            if (!nftImage) return;

            // 1. キャンバス全体をクリア
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // ▼▼▼ [重要] 拡張されたキャンバス内での「画像エリア」を計算 ▼▼▼
            // 全体サイズ
            const totalW = previewCanvas.width;
            const totalH = previewCanvas.height;
            
            // 画像エリアサイズ (余白率 CANVAS_PADDING_RATIO = 0.125 から逆算)
            // Total = Img + 2*Padding = Img * (1 + 0.125*2) = Img * 1.25
            const imgAreaW = totalW / (1 + CANVAS_PADDING_RATIO * 2);
            const imgAreaH = totalH / (1 + CANVAS_PADDING_RATIO * 2);
            
            // 中央に配置するためのオフセット（ズレ）量
            const offsetX = (totalW - imgAreaW) / 2;
            const offsetY = (totalH - imgAreaH) / 2;

            if (isTransparencyApplied) {
                // ====================================================
                // A. 透過後 (Step 3, 4) の描画
                // ====================================================

                // 2. 透過画像 (offscreenCanvas) を描画
                // そのまま描くと左上(0,0)になってしまうので、offsetX, offsetY の位置に描く
                previewCtx.drawImage(offscreenCanvas, offsetX, offsetY, imgAreaW, imgAreaH);

                // 3. 図形 (Manual Mask Shapes) を描画
                // drawShapes() は内部で getCoordinateParams() を呼んで座標変換するため、
                // ここでは特別なオフセット指定は不要（関数内で自動的に計算される）
                drawShapes();

                // 4. トリミングとぼかしのガイド線を描画
                if (isAdjustmentsPreviewOn) {
                    previewCtx.save();
                    // ガイド線の原点を「画像の左上」に合わせる
                    previewCtx.translate(offsetX, offsetY);
                    
                    // ガイド線計算用の幅・高さは「キャンバス全体」ではなく「画像エリア」を使う
                    const imgWidth = imgAreaW;
                    const imgHeight = imgAreaH;
                    
                    const bgColor = getComputedStyle(document.body).getPropertyValue('--background-color').trim();
                    const transparentBgColor = hexToRgba(bgColor, 0);
                    
                    const cropTopPx = (cropParams.top / 100) * imgHeight;
                    const cropBottomPx = (cropParams.bottom / 100) * imgHeight;
                    const cropLeftPx = (cropParams.left / 100) * imgWidth;
                    const cropRightPx = (cropParams.right / 100) * imgWidth;
                    
                    const blurTopPx = (blurParams.top / 100) * imgHeight;
                    const blurBottomPx = (blurParams.bottom / 100) * imgHeight;
                    const blurLeftPx = (blurParams.left / 100) * imgWidth;
                    const blurRightPx = (blurParams.right / 100) * imgWidth;

                    // 外側の塗りつぶし (クロップ範囲外)
                    previewCtx.fillStyle = bgColor;
                    previewCtx.fillRect(0, 0, imgWidth, cropTopPx);
                    previewCtx.fillRect(0, imgHeight - cropBottomPx, imgWidth, cropBottomPx);
                    previewCtx.fillRect(0, cropTopPx, cropLeftPx, imgHeight - cropTopPx - cropBottomPx);
                    previewCtx.fillRect(imgWidth - cropRightPx, cropTopPx, cropRightPx, imgHeight - cropTopPx - cropBottomPx);
                    
                    // ぼかしのグラデーション表示
                    if (blurTopPx > 0) {
                        const grad = previewCtx.createLinearGradient(0, cropTopPx, 0, cropTopPx + blurTopPx);
                        grad.addColorStop(0, bgColor);
                        grad.addColorStop(1, transparentBgColor);
                        previewCtx.fillStyle = grad;
                        previewCtx.fillRect(0, cropTopPx, imgWidth, blurTopPx);
                    }
                    if (blurBottomPx > 0) {
                        const grad = previewCtx.createLinearGradient(0, imgHeight - cropBottomPx - blurBottomPx, 0, imgHeight - cropBottomPx);
                        grad.addColorStop(0, transparentBgColor);
                        grad.addColorStop(1, bgColor);
                        previewCtx.fillStyle = grad;
                        previewCtx.fillRect(0, imgHeight - cropBottomPx - blurBottomPx, imgWidth, blurBottomPx);
                    }
                    if (blurLeftPx > 0) {
                        const grad = previewCtx.createLinearGradient(cropLeftPx, 0, cropLeftPx + blurLeftPx, 0);
                        grad.addColorStop(0, bgColor);
                        grad.addColorStop(1, transparentBgColor);
                        previewCtx.fillStyle = grad;
                        previewCtx.fillRect(cropLeftPx, 0, blurLeftPx, imgHeight);
                    }
                    if (blurRightPx > 0) {
                        const grad = previewCtx.createLinearGradient(imgWidth - cropRightPx - blurRightPx, 0, imgWidth - cropRightPx, 0);
                        grad.addColorStop(0, transparentBgColor);
                        grad.addColorStop(1, bgColor);
                        previewCtx.fillStyle = grad;
                        previewCtx.fillRect(imgWidth - cropRightPx - blurRightPx, 0, blurRightPx, imgHeight);
                    }
                    previewCtx.restore();
                }

            } else {
                // ====================================================
                // B. 透過前 (Step 2) の描画
                // ====================================================
                
                // 元画像を描画 (オフセット位置に)
                previewCtx.drawImage(nftImage, offsetX, offsetY, imgAreaW, imgAreaH);
                
                if (currentMode === 'none') {
                    return;
                }
                
                // マスクプレビューの描画
                // ※ ここは既存のロジックを維持しつつ、描画先だけ offsetX, offsetY に補正します
                const activeMasks = getActiveMasks(currentMode, null); 
                
                // ヘルパー: プレビューの正しい位置に描画する関数
                const drawToPreview = (img) => {
                    if (img && (img.width > 0 || img.tagName === 'CANVAS')) {
                        previewCtx.drawImage(img, offsetX, offsetY, imgAreaW, imgAreaH);
                    }
                };

                if (currentMode === 'head') {
                    const processedHead1Canvas = document.createElement('canvas');
                    processedHead1Canvas.width = offscreenCanvas.width;
                    processedHead1Canvas.height = offscreenCanvas.height;
                    const processedHead1Ctx = processedHead1Canvas.getContext('2d');
                    const drawToCtx = (ctx, images) => {
                        if (images && images.length > 0) {
                            images.forEach(mask => ctx.drawImage(mask, 0, 0, ctx.canvas.width, ctx.canvas.height));
                        }
                    };
                    const createCombinedBodyMask = (bodyLayersArray) => {
                        const bodyCanvas = document.createElement('canvas');
                        bodyCanvas.width = offscreenCanvas.width;
                        bodyCanvas.height = offscreenCanvas.height;
                        const bodyCtx = bodyCanvas.getContext('2d');
                        bodyLayersArray.forEach(bodyLayer => {
                            if (bodyLayer && Array.isArray(bodyLayer)) {
                                const filteredLayer = bodyLayer.filter(img => {
                                    if (document.getElementById('tokenIdInput').value === '1871' && img.src) {
                                        return !decodeURIComponent(img.src).includes('ID_Card');
                                    }
                                    return true;
                                });
                                drawToCtx(bodyCtx, filteredLayer);
                            }
                        });
                        return bodyCanvas;
                    };
                    if (activeMasks.head_layer1) {
                        const tempL1Canvas = document.createElement('canvas');
                        tempL1Canvas.width = offscreenCanvas.width;
                        tempL1Canvas.height = offscreenCanvas.height;
                        const tempL1Ctx = tempL1Canvas.getContext('2d');
                        drawToCtx(tempL1Ctx, activeMasks.head_layer1); 
                        const bodyMaskL1 = createCombinedBodyMask([activeMasks.body_layer1, activeMasks.body_layer2, activeMasks.body_layer3]);
                        tempL1Ctx.globalCompositeOperation = 'destination-out';
                        tempL1Ctx.drawImage(bodyMaskL1, 0, 0); 
                        processedHead1Ctx.globalCompositeOperation = 'source-over';
                        processedHead1Ctx.drawImage(tempL1Canvas, 0, 0); 
                    }
                    if (activeMasks.head_layer2) {
                        const tempL2Canvas = document.createElement('canvas');
                        tempL2Canvas.width = offscreenCanvas.width;
                        tempL2Canvas.height = offscreenCanvas.height;
                        const tempL2Ctx = tempL2Canvas.getContext('2d');
                        drawToCtx(tempL2Ctx, activeMasks.head_layer2); 
                        const bodyMaskL2 = createCombinedBodyMask([activeMasks.body_layer2, activeMasks.body_layer3]);
                        tempL2Ctx.globalCompositeOperation = 'destination-out';
                        tempL2Ctx.drawImage(bodyMaskL2, 0, 0); 
                        processedHead1Ctx.globalCompositeOperation = 'source-over';
                        processedHead1Ctx.drawImage(tempL2Canvas, 0, 0); 
                    }
                    if (activeMasks.head_layer3) {
                        const tempL3Canvas = document.createElement('canvas');
                        tempL3Canvas.width = offscreenCanvas.width;
                        tempL3Canvas.height = offscreenCanvas.height;
                        const tempL3Ctx = tempL3Canvas.getContext('2d');
                        drawToCtx(tempL3Ctx, activeMasks.head_layer3); 
                        const bodyMaskL3 = createCombinedBodyMask([activeMasks.body_layer3]);
                        tempL3Ctx.globalCompositeOperation = 'destination-out';
                        tempL3Ctx.drawImage(bodyMaskL3, 0, 0); 
                        processedHead1Ctx.globalCompositeOperation = 'source-over';
                        processedHead1Ctx.drawImage(tempL3Canvas, 0, 0); 
                    }
                    if (activeMasks.head_layer4) {
                        const tempL4Canvas = document.createElement('canvas');
                        tempL4Canvas.width = offscreenCanvas.width;
                        tempL4Canvas.height = offscreenCanvas.height;
                        const tempL4Ctx = tempL4Canvas.getContext('2d');
                        drawToCtx(tempL4Ctx, activeMasks.head_layer4); 
                        const bodyMaskL4 = createCombinedBodyMask([activeMasks.body_layer4]);
                        tempL4Ctx.globalCompositeOperation = 'destination-out';
                        tempL4Ctx.drawImage(bodyMaskL4, 0, 0); 
                        processedHead1Ctx.globalCompositeOperation = 'source-over';
                        processedHead1Ctx.drawImage(tempL4Canvas, 0, 0); 
                    }
                    drawToPreview(processedHead1Canvas);
                
                } else if (currentMode === 'headBody') {
                    const masksToDraw = [];
                    if (activeMasks.head_layer1) { masksToDraw.push(...activeMasks.head_layer1); }
                    if (activeMasks.head_layer2) { masksToDraw.push(...activeMasks.head_layer2); }
                    if (activeMasks.body_layer1) { masksToDraw.push(...activeMasks.body_layer1); }
                    if (activeMasks.body_layer2) { masksToDraw.push(...activeMasks.body_layer2); }
                    if (activeMasks.head_layer3) { masksToDraw.push(...activeMasks.head_layer3); }
                    if (activeMasks.body_layer3) { masksToDraw.push(...activeMasks.body_layer3); }
                    if (activeMasks.head_layer4) { masksToDraw.push(...activeMasks.head_layer4); }
                    if (activeMasks.body_layer4) { masksToDraw.push(...activeMasks.body_layer4); }
                    
                    if (activeMasks.bp_layer1) {
                        const tailKeywords = ['Cat_Tail', 'Dog_Tail', 'Dragontail'];
                        const tails = activeMasks.bp_layer1.filter(img => {
                            if (!img.src) return false;
                            const src = decodeURIComponent(img.src);
                            return tailKeywords.some(keyword => src.includes(keyword));
                        });
                        if (tails.length > 0) {
                            masksToDraw.push(...tails);
                        }
                    }
                    masksToDraw.forEach(mask => drawToPreview(mask));
                
                } else if (currentMode === 'headBodyBg') {
                    const masksToCombine = [];
                    if (activeMasks.head_layer1) { masksToCombine.push(...activeMasks.head_layer1); }
                    if (activeMasks.head_layer2) { masksToCombine.push(...activeMasks.head_layer2); }
                    if (activeMasks.body_layer1) { masksToCombine.push(...activeMasks.body_layer1); }
                    if (activeMasks.body_layer2) { masksToCombine.push(...activeMasks.body_layer2); }
                    if (activeMasks.head_layer3) { masksToCombine.push(...activeMasks.head_layer3); }
                    if (activeMasks.body_layer3) { masksToCombine.push(...activeMasks.body_layer3); }
                    if (activeMasks.head_layer4) { masksToCombine.push(...activeMasks.head_layer4); }
                    if (activeMasks.body_layer4) { masksToCombine.push(...activeMasks.body_layer4); }
                    if (activeMasks.bp_layer1) { masksToCombine.push(...activeMasks.bp_layer1); }
                    masksToCombine.forEach(mask => drawToPreview(mask));
                }
            }
        }
        const allButtons = document.querySelectorAll('#maskGenreControls button');
        function setActiveButton(activeButton) {
            allButtons.forEach(button => button.classList.remove('active'));
            activeButton.classList.add('active');
        }
        
        function updateButtonStates() {
            // ヘルパー: ボタンの有効/無効を切り替える
            const setBtnState = (btn, isEnabled) => {
                if (isEnabled) {
                    btn.disabled = false;
                    btn.classList.remove('disabled');
                } else {
                    btn.disabled = true;
                    btn.classList.add('disabled');
                    btn.classList.remove('active'); // 非アクティブに見せる
                }
            };

            // -----------------------------------------------------
            // 1. 切り抜き範囲指定ボタン (Range Buttons)
            // -----------------------------------------------------
            
            // 頭系、頭系+体系は常に有効
            setBtnState(headBtn, true);
            setBtnState(headBodyBtn, true);

            // 頭系+体系+背景系: bgマスクがある OR IV例外がある場合のみ有効
            const enableBgBtn = hasBgLayer || isIVException;
            setBtnState(headBodyBgBtn, enableBgBtn);

            // -----------------------------------------------------
            // 2. 切り抜きモード指定ボタン (Mode Buttons)
            // -----------------------------------------------------
            
            let enableNormal = false;
            let enableRecovery = false;

            if (currentMode === 'head') {
                // 通常: 常に有効
                enableNormal = true;
                
                // 補完: 補完画像がある OR Face Shield Blackがある
                // (hasRecoveryLayers は recovery_assets 内の画像有無を包括的にチェックしています)
                enableRecovery = hasRecoveryLayers || isFaceShieldBlackException;

            } else if (currentMode === 'headBody') {
                // 通常: 常に有効
                enableNormal = true;
                
                // 補完: Umbrella系 OR Face Shield Blackがある
                enableRecovery = isUmbrellaException || isFaceShieldBlackException;

            } else if (currentMode === 'headBodyBg') {
                // 特殊補完パーツ (IV, Umbrella, FaceShield) のいずれかがあるか
                const hasSpecialParts = isIVException || isFaceShieldBlackException || isUmbrellaException;

                if (hasBgLayer && !hasSpecialParts) {
                    // ① BGあり かつ 特殊パーツなし -> [通常: ON, 補完: OFF]
                    enableNormal = true;
                    enableRecovery = false;
                } else if (!hasBgLayer && hasSpecialParts) {
                    // ② BGなし かつ 特殊パーツあり -> [通常: OFF, 補完: ON]
                    enableNormal = false;
                    enableRecovery = true;
                } else if (hasBgLayer && hasSpecialParts) {
                    // ③ BGあり かつ 特殊パーツあり -> [通常: ON, 補完: ON]
                    enableNormal = true;
                    enableRecovery = true;
                } else {
                    // どちらもない (そもそもこのモードを選べないはずだが念のため)
                    enableNormal = false;
                    enableRecovery = false;
                }
            }

            setBtnState(modeNormalBtn, enableNormal);
            setBtnState(modeRecoveryBtn, enableRecovery);

            // ▼▼▼ モードの自動切り替えとビジュアル同期 ▼▼▼
            
            // 1. 現在選択中のモードが「無効」になってしまった場合、有効な方へ内部変数をスイッチする
            if (currentMaskingType === 'Mask' && !enableNormal && enableRecovery) {
                console.log("★ モード自動切り替え: Normal -> Recovery");
                currentMaskingType = 'Recovery';
            } else if (currentMaskingType === 'Recovery' && !enableRecovery && enableNormal) {
                console.log("★ モード自動切り替え: Recovery -> Normal");
                currentMaskingType = 'Mask';
            }

            // 2. 現在の currentMaskingType に合わせて、見た目(activeクラス)を強制的に同期する
            if (currentMaskingType === 'Mask' && enableNormal) {
                modeNormalBtn.classList.add('active');
                modeRecoveryBtn.classList.remove('active');
            } else if (currentMaskingType === 'Recovery' && enableRecovery) {
                modeRecoveryBtn.classList.add('active');
                modeNormalBtn.classList.remove('active');
            } else {
                // どちらも選べない状態なら選択解除
                modeNormalBtn.classList.remove('active');
                modeRecoveryBtn.classList.remove('active');
            }
        }

        function handleModeChange(mode, button) {
            currentMode = mode;
            isTransparencyApplied = false;
            
            // 範囲ボタンのアクティブ切り替え
            const genreButtons = document.querySelectorAll('#maskGenreControls button');
            genreButtons.forEach(b => b.classList.remove('active'));
            if (button) button.classList.add('active');
            updateButtonStates();
            updateRecoveryPartsPreview(mode);

            // 肩周り補正の表示制御のみ行う（プレビューは更新しない）
            if (mode === 'head' && Object.keys(underHairFixMasks).length > 0) {
                strayHairControl.classList.remove('hidden');
            } else {
                strayHairControl.classList.add('hidden');
            }
            
            // 下流のUIリセット
            stepManualCut.classList.add('hidden');
            stepTrimAndBlur.classList.add('hidden');
            step3.classList.add('hidden');
            shapes = [];
            updateCutModeUI();
            
            // ステータスメッセージをクリア
            statusMessage2.textContent = '';
            statusMessage2.classList.remove('loading');
            resetZoomPan();
            
            // ▼▼▼ モード切り替え直後の状態を履歴の起点として保存 ▼▼▼
            // (非同期で画像がセットされた後に実行する必要があるため、少し遅延させるか、
            //  applyTransparencyの後に呼ぶのが確実ですが、ここでは簡易的に初期化します)
            setTimeout(() => {
                if (offscreenCanvas.width > 0) {
                    initHistory(); 
                }
            }, 100);
        }
        
        // ▼▼▼ 範囲選択ボタン（プレビュー更新をしない） ▼▼▼
        headBtn.addEventListener('click', () => handleModeChange('head', headBtn));
        headBodyBtn.addEventListener('click', () => handleModeChange('headBody', headBodyBtn));
        headBodyBgBtn.addEventListener('click', () => handleModeChange('headBodyBg', headBodyBgBtn));
        modeNormalBtn.addEventListener('click', () => {
            currentMaskingType = 'Mask';
            modeNormalBtn.classList.add('active');
            modeRecoveryBtn.classList.remove('active');
        });

        modeRecoveryBtn.addEventListener('click', () => {
            currentMaskingType = 'Recovery';
            modeRecoveryBtn.classList.add('active');
            modeNormalBtn.classList.remove('active');
        });

        // ▼▼▼ 肩周り補正ボタン（プレビュー更新をしない） ▼▼▼
        strayHairFixOnBtn.addEventListener('click', () => {
            if (isStrayHairFixOn) return;
            isStrayHairFixOn = true;
            strayHairFixOnBtn.classList.add('active');
            strayHairFixOffBtn.classList.remove('active');
        });
        
        strayHairFixOffBtn.addEventListener('click', () => {
            if (!isStrayHairFixOn) return;
            isStrayHairFixOn = false;
            strayHairFixOffBtn.classList.add('active');
            strayHairFixOnBtn.classList.remove('active');
        });

        // ▼▼▼ プレビュー表示ボタン ▼▼▼
        doPreviewBtn.addEventListener('click', () => {
            if (currentMode === 'none') {
                statusMessage2.textContent = getMessage('maskModeRequired'); 
                statusMessage2.dataset.langKey = 'maskModeRequired';
                statusMessage2.dataset.langVars = '{}';
                return;
            }
            statusMessage2.textContent = 'プレビューを作成中...';
            statusMessage2.classList.add('loading');
            // 少し待ってから描画（UIブロック回避）
            setTimeout(() => {
                updatePreview();
                statusMessage2.textContent = '';
                statusMessage2.classList.remove('loading');
            }, 50);
        });

        doExecuteBtn.addEventListener('click', () => {
            // 現在選択されているモードに基づいて実行
            const isRecovery = (currentMaskingType === 'Recovery');
            applyTransparency(isRecovery);
        });

        // ▼▼▼ 補完パーツのプレビューを更新する関数 ▼▼▼
        function updateRecoveryPartsPreview(mode) {
            const container = document.getElementById('recoveryPartsContainer');
            const list = document.getElementById('recoveryPartsList');
            list.innerHTML = ''; 

            // 表示対象の画像URLリスト
            let imagesToShow = [];
            const tokenId = tokenIdInput.value;

            // 1. recoveryImgs (APIから取得した補完画像) から、Headモード用の特定の画像を集める
            let headRecoveryAssets = [];
            
            // recoveryImgs は { layerName: [img, img...] } の形なのでフラットにする
            for (const layer in recoveryImgs) {
                if (Array.isArray(recoveryImgs[layer])) {
                    recoveryImgs[layer].forEach(img => {
                        if (img && img.src) {
                            const src = decodeURIComponent(img.src);
                            if (src.includes('/Body Layer/') || 
                                src.includes('/Face Accessories/') || 
                                src.includes('/Head/') ||
                                src.includes('recovery_layer2_Multicolor_Scarf_Black_3818.png') ||
                                (tokenId === '2331' && (src.includes('Twintails_2331.png') || src.includes('Mekakure_2331.png')))) {
                                headRecoveryAssets.push(src);
                            }
                        }
                    });
                }
            }

            // 2. モードごとの表示ロジック
            if (mode === 'head') {
                // ・recovery_assets内の特定画像
                imagesToShow.push(...headRecoveryAssets);
                // ・face shield Black
                if (isFaceShieldBlackException) {
                    imagesToShow.push('/assets/Exception/FaceShiledBlack.png');
                }

            } else if (mode === 'headBody') {
                // ・Umbrella
                if (isUmbrellaException && tokenId) {
                    imagesToShow.push(`/assets/Exception/Umbrella_${tokenId}.png`);
                }
                // ・face shield Black
                if (isFaceShieldBlackException) {
                    imagesToShow.push('/assets/Exception/FaceShiledBlack.png');
                }

            } else if (mode === 'headBodyBg') {
                // ・IV (最背面なので先頭に追加)
                if (isIVException) {
                    imagesToShow.push('/assets/Exception/IV.png');
                }
                // ・face shield Black
                if (isFaceShieldBlackException) {
                    imagesToShow.push('/assets/Exception/FaceShiledBlack.png');
                }
                // ・Umbrella
                if (isUmbrellaException && tokenId) {
                    imagesToShow.push(`/assets/Exception/Umbrella_${tokenId}.png`);
                }
            }

            // 3. 重複排除
            imagesToShow = [...new Set(imagesToShow)];

            // 4. DOM生成
            if (imagesToShow.length > 0) {
                container.classList.remove('hidden');
                imagesToShow.forEach(src => {
                    const img = document.createElement('img');
                    img.src = src;
                    img.className = 'recovery-preview-img';  
                    // ▼▼▼ 右クリック禁止 (保存防止) ▼▼▼
                    img.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                    });
                    // ロードエラー時は非表示にする
                    img.onerror = () => { img.style.display = 'none'; };
                    
                    list.appendChild(img);
                });
            } else {
                container.classList.add('hidden');
            }
        } 

        async function applyTransparency(isRecovery = false) {
            if (!nftImage) {
                statusMessage2.textContent = getMessage('nftImageRequired');
                statusMessage2.dataset.langKey = 'nftImageRequired';
                statusMessage2.dataset.langVars = '{}';
                return;
            }
            if (currentMode === 'none') {
                statusMessage2.textContent = getMessage('maskModeRequired');
                statusMessage2.dataset.langKey = 'maskModeRequired';
                statusMessage2.dataset.langVars = '{}';
                return;
            }

            if (currentTokenException) {
                const ruleMatchesMode = !currentTokenException.mode || currentTokenException.mode === currentMode;
                if (ruleMatchesMode && currentTokenException.type === 'SPECIAL_LOGIC') {
                    // (ここに将来の特殊ロジックを実装する)
                    // return; 
                }
            }

            const msgKey = isRecovery ? 'processingRecoveryMask' : 'processingMask';
            statusMessage2.textContent = getMessage(msgKey);
            statusMessage2.dataset.langKey = msgKey;
            statusMessage2.dataset.langVars = '{}';
            statusMessage2.classList.add('loading');
            stepManualCut.classList.add('hidden');
            stepTrimAndBlur.classList.add('hidden');
            step3.classList.add('hidden');

            setTimeout(async () => {
                try {
                    const canvasWidth = offscreenCanvas.width;
                    const canvasHeight = offscreenCanvas.height;
                    const createTempCanvas = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = canvasWidth;
                        canvas.height = canvasHeight;
                        return canvas;
                    };
                    const drawImagesOnCanvas = (canvas, images) => {
                        const ctx = canvas.getContext('2d');
                        if (images) images.forEach(img => {
                            if (img && (img.width > 0 || img.tagName === 'CANVAS')) { 
                                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                            }
                        });
                    };

                    const activeMasks = getActiveMasks(currentMode, isRecovery);

                    if (!isRecovery) {
                        const finalMaskCanvas = createTempCanvas();
                        const finalMaskCtx = finalMaskCanvas.getContext('2d');
                        if (currentMode === 'head') {
                            const processHeadLayer = (headLayers, bodyLayersArray) => {
                                const canvas = createTempCanvas(); 
                                const ctx = canvas.getContext('2d');
                                drawImagesOnCanvas(canvas, headLayers); 
                                if (bodyLayersArray && bodyLayersArray.length > 0) {
                                    const combinedBodyMask = createTempCanvas(); 
                                    const bodyCtx = combinedBodyMask.getContext('2d');
                                    bodyLayersArray.forEach(bodyLayer => {
                                        if (bodyLayer && Array.isArray(bodyLayer)) {
                                        // ▼▼▼ ID 1871 の場合、ID Card を切り抜きマスクから除外 ▼▼▼
                                            const filteredLayer = bodyLayer.filter(img => {
                                                if (document.getElementById('tokenIdInput').value === '1871' && img.src) {
                                                    const isIDCard = decodeURIComponent(img.src).includes('ID_Card');
                                                    if (isIDCard) {
                                                        console.log("★ Clipping: ID 1871 例外 - ID Card を頭切り抜きマスクから除外しました。");
                                                    }
                                                    return !isIDCard;
                                                }
                                                return true;
                                            });
                                            drawImagesOnCanvas(combinedBodyMask, filteredLayer);
                                        }
                                    });
                                    ctx.globalCompositeOperation = 'destination-out';
                                    ctx.drawImage(combinedBodyMask, 0, 0);
                                    ctx.globalCompositeOperation = 'source-over';
                                }
                                return canvas; 
                            };
                            finalMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer1, [activeMasks.body_layer1, activeMasks.body_layer2, activeMasks.body_layer3]), 0, 0);
                            finalMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer2, [activeMasks.body_layer2, activeMasks.body_layer3]), 0, 0);
                            finalMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer3, [activeMasks.body_layer3]), 0, 0);
                            finalMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer4, [activeMasks.body_layer4]), 0, 0);
                        } else if (currentMode === 'headBody' || currentMode === 'headBodyBg') {
                            const layersToCombine = ['head_layer1', 'head_layer2', 'body_layer1', 'body_layer2', 'head_layer3', 'body_layer3', 'head_layer4', 'body_layer4'];
                            if (currentMode === 'headBodyBg') layersToCombine.push('bp_layer1');
                            layersToCombine.forEach(layer => drawImagesOnCanvas(finalMaskCanvas, activeMasks[layer]));
                            // ▼▼▼ HeadBodyモード時、尻尾パーツ(bp_layer1)を例外的に追加 ▼▼▼
                            if (currentMode === 'headBody' && activeMasks.bp_layer1) {
                                const tailKeywords = ['Cat_Tail', 'Dog_Tail', 'Dragontail'];
                                const tails = activeMasks.bp_layer1.filter(img => {
                                    if (!img.src) return false;
                                    const src = decodeURIComponent(img.src);
                                    return tailKeywords.some(keyword => src.includes(keyword));
                                });
                                if (tails.length > 0) {
                                    drawImagesOnCanvas(finalMaskCanvas, tails);
                                    console.log("★ ApplyTransparency (HeadBody): 尻尾パーツをマスクに追加しました。", tails);
                                }
                            }
                        }
                        offscreenCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                        offscreenCtx.drawImage(nftImage, 0, 0, canvasWidth, canvasHeight);
                        offscreenCtx.globalCompositeOperation = 'destination-in';
                        offscreenCtx.drawImage(finalMaskCanvas, 0, 0);
                        offscreenCtx.globalCompositeOperation = 'source-over';

                    } else {
                        const processedRecoveryImgs = {};
                        for (const layer in recoveryImgs) {
                            if (Array.isArray(recoveryImgs[layer])) {
                                processedRecoveryImgs[layer] = [...recoveryImgs[layer]]; 
                            }
                        }
                        const shouldFixStrayHairRecovery = currentMode === 'head' && isStrayHairFixOn && Object.keys(underHairFixMasks).length > 0;
                        
                        console.log("★ Recovery: 補完透過処理を開始します。", { 
                            currentMode: currentMode, 
                            recoveryImgs: recoveryImgs, 
                            processedRecoveryImgs: processedRecoveryImgs,
                            shouldFixStrayHairRecovery: shouldFixStrayHairRecovery
                        });

                        if (shouldFixStrayHairRecovery) {
                            console.log(`★ UnderHair Fix (applyTransparency / recoveryImgs): 適用処理を実行します...`);
                            for (const layer in processedRecoveryImgs) {
                                if (Array.isArray(processedRecoveryImgs[layer])) {
                                    processedRecoveryImgs[layer] = processedRecoveryImgs[layer].map(originalImg => {
                                        if (!originalImg || !originalImg.src) {
                                            return originalImg;
                                        }
                                        const fileName = originalImg.src.split('/').pop();
                                        const match = fileName.match(/^(?:.*_layer\d+_)?(.*)\.png$/i);
                                        let fixMask = null;
                                        let baseName = null;
                                        if (match && match[1]) {
                                            baseName = match[1];
                                            fixMask = underHairFixMasks[baseName];
                                        }
                                        if (fixMask) {
                                            console.log(`★ UnderHair Fix (applyTransparency): [実行] 補正マスク ${fixMask.src} (key: ${baseName}) を使って、補完画像 ${originalImg.src} をくり抜きます。`);
                                            const tempCanvas = createTempCanvas();
                                            const tempCtx = tempCanvas.getContext('2d');
                                            tempCtx.drawImage(originalImg, 0, 0, canvasWidth, canvasHeight);
                                            tempCtx.globalCompositeOperation = 'destination-out';
                                            tempCtx.drawImage(fixMask, 0, 0, canvasWidth, canvasHeight);
                                            tempCtx.globalCompositeOperation = 'source-over';
                                            return tempCanvas; 
                                        } else {
                                            const decodedSrc = decodeURIComponent(originalImg.src);
                                            if (decodedSrc && decodedSrc.includes('/assets/recovery_assets/Under Hair/')) {
                                                console.log(`★ UnderHair Fix (applyTransparency): [スキップ] ${originalImg.src} (base: ${baseName}) は補完UnderHair画像ですが、対応する補正マスクが見つかりませんでした。`);
                                            }
                                            return originalImg;
                                        }
                                    });
                                }
                            }
                        }
                        const isFaceShieldBlackException = nftTraits.some(trait => trait.trait_type === 'Face Accessories' && trait.value === 'Face Shiled Black');
                        const umbrellaAliases = ["Black Umbrella", "Blue Umbrella", "Red Umbrella", "White Umbrella", "Yellow Umbrella"];
                        const isUmbrellaException = nftTraits.some(trait => trait.trait_type === 'Hand' && umbrellaAliases.includes(trait.value));
                        
                        if (currentMode === 'head') {
                            console.log("★ Recovery: 'head' モードの補完処理を実行します。");

                            const processedRecoveryCanvas = createTempCanvas();
                            const processedRecoveryCtx = processedRecoveryCanvas.getContext('2d');
                            // excludeFilter: 画像を除外するための関数 (img => boolean)
                            const createClippingMask = (layers, excludeFilter = null) => {
                                const mask = createTempCanvas();
                                const ctx = mask.getContext('2d');
                                
                                layers.forEach(layerKey => {
                                    const images = activeMasks[layerKey];
                                    if (images) {
                                        images.forEach(img => {
                                            // 除外フィルターがあり、かつ条件にマッチしたら描画しない
                                            if (excludeFilter && excludeFilter(img)) {
                                                return; 
                                            }
                                            // ▼▼▼ ID 1871 の場合、ID Card を補完切り抜きマスクから除外 ▼▼▼
                                            if (document.getElementById('tokenIdInput').value === '1871' && img.src) {
                                                if (decodeURIComponent(img.src).includes('ID_Card')) {
                                                    console.log("★ Recovery Clipping: ID 1871 例外 - ID Card を除外しました。");
                                                    return;
                                                }
                                            }
                                            if (img && (img.width > 0 || img.tagName === 'CANVAS')) {
                                                ctx.drawImage(img, 0, 0, mask.width, mask.height);
                                            }
                                        });
                                    }
                                });
                                return mask;
                            };
                            const clipAndDraw = (targetImages, clippingMask) => {
                                if (!targetImages || targetImages.length === 0) {
                                    console.log(`★ Recovery: clipAndDraw - スキップ (対象画像なし)`);
                                    return;
                                }
                                console.log(`★ Recovery: clipAndDraw - 実行 (対象画像 ${targetImages.length} 件)`, targetImages.map(img => img.src || 'canvas'));

                                if (!targetImages) return;
                                const temp = createTempCanvas();
                                const tempCtx = temp.getContext('2d');
                                drawImagesOnCanvas(temp, targetImages);
                                tempCtx.globalCompositeOperation = 'destination-out';
                                tempCtx.drawImage(clippingMask, 0, 0);
                                processedRecoveryCtx.drawImage(temp, 0, 0);
                            };
                            clipAndDraw(processedRecoveryImgs.recovery_layer1, createClippingMask(['head_layer2', 'head_layer3', 'head_layer4']));
                            
                            // 'recovery_layer2' の処理を、順序を制御して2回実行する
                            
                            // 1. 後ろ側 (Body Layer) を描画
                            clipAndDraw(processedRecoveryImgs.recovery_layer2_body, createClippingMask(['head_layer3', 'head_layer4']));
                            
                            // 2. 'recovery_layer2' (もしあれば) を描画
                            clipAndDraw(processedRecoveryImgs.recovery_layer2, createClippingMask(['head_layer3', 'head_layer4']));
                            
                            // 3. 前側 (Face Accessories) を描画
                            // ガスマスク系の画像を特定するためのキーワード
                            const gasmaskKeywords = ['Gasmask', 'Gasmask_Bicolor']; 

                            const gasmaskClippingMask = createClippingMask(
                                ['head_layer3', 'head_layer4'], 
                                (img) => {
                                    // 画像のsrcにキーワードが含まれていたら「除外(true)」する
                                    if (!img.src) return false;
                                    const src = decodeURIComponent(img.src);
                                    return gasmaskKeywords.some(keyword => src.includes(keyword));
                                }
                            );

                            clipAndDraw(processedRecoveryImgs.recovery_layer2_face, gasmaskClippingMask);
                            
                            // ▼▼▼ recovery_layer3 (Helmet等) を、前髪(head_layer4)に加えてエフェクト(Flame/Lightning)でも切り抜く ▼▼▼
                            const layer3ClippingMask = createClippingMask(['head_layer4']);
                            const l3MaskCtx = layer3ClippingMask.getContext('2d');

                            // エフェクト例外画像があれば、それをクリッピングマスクに追加合成する
                            if (blueLightningExceptionImg && blueLightningExceptionImg.width > 0) {
                                l3MaskCtx.drawImage(blueLightningExceptionImg, 0, 0, canvasWidth, canvasHeight);
                                console.log("★ Recovery: Combat Helmet (layer3) を Blue Lightning でクリッピングします。");
                            }
                            if (flameExceptionImg && flameExceptionImg.width > 0) {
                                l3MaskCtx.drawImage(flameExceptionImg, 0, 0, canvasWidth, canvasHeight);
                                console.log("★ Recovery: Combat Helmet (layer3) を Flame でクリッピングします。");
                            }

                            clipAndDraw(processedRecoveryImgs.recovery_layer3, layer3ClippingMask);
                            console.log("★ Recovery: drawImagesOnCanvas (recovery_layer4) を呼び出します。", processedRecoveryImgs.recovery_layer4 ? processedRecoveryImgs.recovery_layer4.map(img => img.src || 'canvas') : 'なし');
                            drawImagesOnCanvas(processedRecoveryCanvas, processedRecoveryImgs.recovery_layer4);

                            const mainMaskCanvas = createTempCanvas();
                            const mainMaskCtx = mainMaskCanvas.getContext('2d');
                            const processHeadLayer = (headLayers, bodyLayersArray) => {
                                const canvas = createTempCanvas(); 
                                const ctx = canvas.getContext('2d');
                                drawImagesOnCanvas(canvas, headLayers); 
                                if (bodyLayersArray && bodyLayersArray.length > 0) {
                                    const combinedBodyMask = createTempCanvas(); 
                                    const bodyCtx = combinedBodyMask.getContext('2d');
                                    bodyLayersArray.forEach(bodyLayer => {
                                        if (bodyLayer && Array.isArray(bodyLayer)) {
                                            drawImagesOnCanvas(combinedBodyMask, bodyLayer);
                                        }
                                    });
                                    ctx.globalCompositeOperation = 'destination-out';
                                    ctx.drawImage(combinedBodyMask, 0, 0);
                                    ctx.globalCompositeOperation = 'source-over';
                                }
                                return canvas;
                            };
                            mainMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer1, [activeMasks.body_layer1, activeMasks.body_layer2, activeMasks.body_layer3]), 0, 0);
                            mainMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer2, [activeMasks.body_layer2, activeMasks.body_layer3]), 0, 0);
                            mainMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer3, [activeMasks.body_layer3]), 0, 0);
                            mainMaskCtx.drawImage(processHeadLayer(activeMasks.head_layer4, [activeMasks.body_layer4]), 0, 0);
                            const nftFinalMaskCanvas = createTempCanvas();
                            const nftFinalMaskCtx = nftFinalMaskCanvas.getContext('2d');
                            nftFinalMaskCtx.drawImage(mainMaskCanvas, 0, 0);
                            nftFinalMaskCtx.globalCompositeOperation = 'destination-out';
                            nftFinalMaskCtx.drawImage(processedRecoveryCanvas, 0, 0);
                            nftFinalMaskCtx.globalCompositeOperation = 'source-over';
                            
                            let clippedFaceShieldCanvas = null;
                            if (isFaceShieldBlackException) {
                                const faceShieldImage = await loadImage('/assets/Exception/FaceShiledBlack.png');
                                
                                if (faceShieldImage && faceShieldImage.width > 0) {
                                    clippedFaceShieldCanvas = createTempCanvas();
                                    const clippedFSCtx = clippedFaceShieldCanvas.getContext('2d');
                                    const powerpointCanvasSize = 140; 
                                    const relativeX = 49.15 / powerpointCanvasSize;
                                    const relativeY = 49.9 / powerpointCanvasSize;
                                    const drawX = relativeX * canvasWidth;
                                    const drawY = relativeY * canvasHeight;
                                    const relativeWidth = 41.62 / powerpointCanvasSize;
                                    const relativeHeight = 42.11 / powerpointCanvasSize;
                                    const drawWidth = relativeWidth * canvasWidth;
                                    const drawHeight = relativeHeight * canvasHeight;
                                    clippedFSCtx.drawImage(faceShieldImage, drawX, drawY, drawWidth, drawHeight);
                                    clippedFSCtx.globalCompositeOperation = 'destination-out'; 
                                    clippedFSCtx.drawImage(nftFinalMaskCanvas, 0, 0);
                                    clippedFSCtx.globalCompositeOperation = 'source-over';
                                } else {
                                    console.warn('Face Shiled Black 例外画像のロードに失敗したため、スキップします。');
                                }
                            }
                            
                            offscreenCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                            offscreenCtx.drawImage(nftImage, 0, 0, canvasWidth, canvasHeight);
                            offscreenCtx.globalCompositeOperation = 'destination-in';
                            offscreenCtx.drawImage(nftFinalMaskCanvas, 0, 0);
                            offscreenCtx.globalCompositeOperation = 'source-over';

                            console.log("★ Recovery: 最終合成 (offscreenCtx.drawImage(processedRecoveryCanvas)) を実行します。");
                            offscreenCtx.drawImage(processedRecoveryCanvas, 0, 0);

                            if (isFaceShieldBlackException && clippedFaceShieldCanvas) {
                                offscreenCtx.drawImage(clippedFaceShieldCanvas, 0, 0);
                            }

                        } else { 

                            console.log(`★ Recovery: '${currentMode}' モードの補完処理を実行します。`);

                        // 1. メインのマスクを作成
                        const finalMaskCanvas = createTempCanvas();
                        const layersToCombine = ['head_layer1', 'head_layer2', 'body_layer1', 'body_layer2', 'head_layer3', 'body_layer3', 'head_layer4', 'body_layer4'];
                        if (currentMode === 'headBodyBg') layersToCombine.push('bp_layer1');
                        layersToCombine.forEach(layer => drawImagesOnCanvas(finalMaskCanvas, activeMasks[layer]));
                        // ▼▼▼ HeadBodyモード時、尻尾パーツ(bp_layer1)を例外的に追加 ▼▼▼
                        if (currentMode === 'headBody' && activeMasks.bp_layer1) {
                            const tailKeywords = ['Cat_Tail', 'Dog_Tail', 'Dragontail'];
                            const tails = activeMasks.bp_layer1.filter(img => {
                                if (!img.src) return false;
                                const src = decodeURIComponent(img.src);
                                return tailKeywords.some(keyword => src.includes(keyword));
                            });
                            if (tails.length > 0) {
                                drawImagesOnCanvas(finalMaskCanvas, tails);
                                console.log("★ ApplyTransparency (Recovery/HeadBody): 尻尾パーツをマスクに追加しました。");
                            }
                        }
                        // 2. KRG画像をくり抜く (結果は offscreenCanvas に入る)
                        offscreenCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                        offscreenCtx.drawImage(nftImage, 0, 0, canvasWidth, canvasHeight);
                        offscreenCtx.globalCompositeOperation = 'destination-in';
                        offscreenCtx.drawImage(finalMaskCanvas, 0, 0);
                        offscreenCtx.globalCompositeOperation = 'source-over';

                        // 3. 例外処理のために一時キャンバスを用意
                        const tempCompositeCanvas = createTempCanvas();
                        const tempCompositeCtx = tempCompositeCanvas.getContext('2d');
                        let useTempComposite = false;

                        // 4. [最背面] IV 例外 (リクエスト通り headBodyBg モードの時のみ)
                        if (isIVException && currentMode === 'headBodyBg' && IVExceptionImg && IVExceptionImg.width > 0) {
                            console.log("★ IV 例外: 補完処理 (headBodyBg) で IV.png を最背面に合成します。");
                            tempCompositeCtx.drawImage(IVExceptionImg, 0, 0, canvasWidth, canvasHeight);
                            useTempComposite = true;
                        } else if (isIVException && currentMode === 'headBodyBg') {
                            console.warn("★ IV 例外: IVExceptionImg がロードされていません。");
                        }

                        // 5. [特殊背景] Umbrella 例外
                        if (isUmbrellaException) {
                            const tokenId = tokenIdInput.value;
                            if (!tokenId) {
                                console.error("Umbrella例外処理エラー: トークンIDがありません。");
                                throw new Error("トークンID不明のためUmbrella例外処理失敗");
                            }
                            const exceptionImageUrl = `/assets/Exception/Umbrella_${tokenId}.png`;
                            const umbrellaImage = await loadImage(exceptionImageUrl); 

                            if (umbrellaImage && umbrellaImage.width > 0) { 
                                tempCompositeCtx.drawImage(umbrellaImage, 0, 0, canvasWidth, canvasHeight); // IV の上に Umbrella (背景) を描画
                            } else {
                                console.warn(`Umbrella例外画像 ${exceptionImageUrl} が見つからないため、背景なしで処理します。`);
                            }
                            useTempComposite = true;
                        }
                        // 7. [最前面] FaceShield 例外
                        if (isFaceShieldBlackException) {
                            const faceShieldImage = await loadImage('/assets/Exception/FaceShiledBlack.png');

                            if (faceShieldImage && faceShieldImage.width > 0) {
                                const powerpointCanvasSize = 140; 
                                const relativeX = 49.15 / powerpointCanvasSize;
                                const relativeY = 49.9 / powerpointCanvasSize;
                                const drawX = relativeX * canvasWidth;
                                const drawY = relativeY * canvasHeight;
                                const relativeWidth = 41.62 / powerpointCanvasSize;
                                const relativeHeight = 42.11 / powerpointCanvasSize;
                                const drawWidth = relativeWidth * canvasWidth;
                                const drawHeight = relativeHeight * canvasHeight;

                                tempCompositeCtx.drawImage(faceShieldImage, drawX, drawY, drawWidth, drawHeight); // KRG の上に FaceShield を描画
                                useTempComposite = true;
                            } else {
                                 console.warn('Face Shiled Black 例外画像のロードに失敗したため、スキップします。');
                            }
                        }

                        // 6. [KRG本体] KRG を (IV や Umbrella の) 上に描画
                        tempCompositeCtx.drawImage(offscreenCanvas, 0, 0);
                        useTempComposite = true; // KRG は必ず描画する

                        
                        
                        // 8. 最終合成
                        if (useTempComposite) {
                            offscreenCtx.clearRect(0, 0, canvasWidth, canvasHeight);
                            offscreenCtx.drawImage(tempCompositeCanvas, 0, 0);
                        }
                        }
                    }

                    // ▼▼▼ 切り抜きタイプを記録 ▼▼▼
                    currentMaskingType = isRecovery ? 'Recovery' : 'Mask';

                    isTransparencyApplied = true;
                    updatePreview();
                    const msgKeySuccess = isRecovery ? 'processRecoverySuccess' : 'processSuccess';
                    statusMessage2.textContent = getMessage(msgKeySuccess);
                    statusMessage2.dataset.langKey = msgKeySuccess;
                    statusMessage2.dataset.langVars = '{}';
                    statusMessage2.classList.remove('loading');
                    stepManualCut.classList.remove('hidden');
                    stepManualCut.classList.add('slide-in');
                    stepTrimAndBlur.classList.remove('hidden'); 
                    stepTrimAndBlur.classList.add('slide-in');
                    step3.classList.remove('hidden'); 
                    step3.classList.add('slide-in');
                    
                    updateCutModeUI();
                    
                    // ▼▼▼ 自動切り抜き完了時点を「履歴のスタート地点」として保存 ▼▼▼
                    initHistory();

                } catch (error) {
                    console.error('透過処理エラー(詳細):', error);
                    statusMessage2.textContent = getMessage('processError');
                    statusMessage2.dataset.langKey = 'processError';
                    statusMessage2.dataset.langVars = '{}';
                    statusMessage2.classList.remove('loading');
                }
            }, 0);
        }
        
        saveImageBtn.addEventListener('click', () => {
            if (!isTransparencyApplied) {
                console.warn(getMessage('noImageToSave')); 
                return;
            }

            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            
            const imgWidth = offscreenCanvas.width;
            const imgHeight = offscreenCanvas.height;
            
            const cropTopPx = (cropParams.top / 100) * imgHeight;
            const cropBottomPx = (cropParams.bottom / 100) * imgHeight;
            const cropLeftPx = (cropParams.left / 100) * imgWidth;
            const cropRightPx = (cropParams.right / 100) * imgWidth;
            
            const croppedWidth = imgWidth - cropLeftPx - cropRightPx;
            const croppedHeight = imgHeight - cropTopPx - cropBottomPx;
            
            // 選択された目標ピクセル数 (例: 16384, 3840, 1080)
            const targetBaseSize = parseInt(saveSizeSelect.value); 
            // 元画像のサイズ (16384px)
            const originalBaseSize = imgWidth; // (imgWidth は offscreenCanvas.width です)
            
            // スケール（倍率）を計算 (例: 3840 / 16384 = 0.234375)
            const scaleFactor = targetBaseSize / originalBaseSize;
            
            // トリミングを考慮した最終的な幅と高さを計算
            // (croppedWidth/Height は 16384px空間での値)
            const newWidth = croppedWidth * scaleFactor;
            const newHeight = croppedHeight * scaleFactor;
            
            finalCanvas.width = newWidth;
            finalCanvas.height = newHeight;
            
            finalCtx.drawImage(
                offscreenCanvas, 
                cropLeftPx, cropTopPx, 
                croppedWidth, croppedHeight, 
                0, 0, 
                newWidth, newHeight
            );

            const blurMaskCanvas = document.createElement('canvas');
            blurMaskCanvas.width = newWidth;
            blurMaskCanvas.height = newHeight;
            const blurMaskCtx = blurMaskCanvas.getContext('2d');
            
            const blurTopPx = (blurParams.top / 100) * newHeight;
            const blurBottomPx = (blurParams.bottom / 100) * newHeight;
            const blurLeftPx = (blurParams.left / 100) * newWidth;
            const blurRightPx = (blurParams.right / 100) * newWidth;

            if (blurTopPx > 0) {
                const grad = blurMaskCtx.createLinearGradient(0, 0, 0, blurTopPx);
                grad.addColorStop(0, 'rgba(0,0,0,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                blurMaskCtx.fillStyle = grad;
                blurMaskCtx.fillRect(0, 0, newWidth, blurTopPx);
            }
            if (blurBottomPx > 0) {
                const grad = blurMaskCtx.createLinearGradient(0, newHeight - blurBottomPx, 0, newHeight);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,1)');
                blurMaskCtx.fillStyle = grad;
                blurMaskCtx.fillRect(0, newHeight - blurBottomPx, newWidth, blurBottomPx);
            }
            if (blurLeftPx > 0) {
                const grad = blurMaskCtx.createLinearGradient(0, 0, blurLeftPx, 0);
                grad.addColorStop(0, 'rgba(0,0,0,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                blurMaskCtx.fillStyle = grad;
                blurMaskCtx.fillRect(0, 0, blurLeftPx, newHeight);
            }
            if (blurRightPx > 0) {
                const grad = blurMaskCtx.createLinearGradient(newWidth - blurRightPx, 0, newWidth, 0);
                grad.addColorStop(0, 'rgba(0,0,0,0)');
                grad.addColorStop(1, 'rgba(0,0,0,1)');
                blurMaskCtx.fillStyle = grad;
                blurMaskCtx.fillRect(newWidth - blurRightPx, 0, blurRightPx, newHeight);
            }
            
            finalCtx.globalCompositeOperation = 'destination-out';
            finalCtx.drawImage(blurMaskCanvas, 0, 0);
            finalCtx.globalCompositeOperation = 'source-over';
            
            const dataURL = finalCanvas.toDataURL('image/png');
            const link = document.createElement('a');

            // 1. 切り抜き範囲の文字列決定
            let areaName = 'Unknown';
            if (currentMode === 'head') areaName = 'Head';
            else if (currentMode === 'headBody') areaName = 'HeadBody';
            else if (currentMode === 'headBodyBg') areaName = 'HeadBodyBg';

            // 2. ファイル名の組み立て: KRG_ID_範囲_方法_解像度.png
            const tokenId = tokenIdInput.value;
            const resolution = saveSizeSelect.value;
            
            link.download = `KRG_${tokenId}_${areaName}_${currentMaskingType}_${resolution}px.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        function setupSliderInput(slider, input, paramKey, paramsObject) {
            const updateValue = (value) => {
                const correctedValue = parseFloat(Math.max(0, Math.min(value, 100.0)).toFixed(1));
                input.value = correctedValue;
                slider.value = correctedValue;
                paramsObject[paramKey] = correctedValue;
                if (isTransparencyApplied) updatePreview(); 
            };
            slider.addEventListener('input', (e) => updateValue(e.target.value));
            input.addEventListener('change', (e) => updateValue(e.target.value));
            input.addEventListener('focus', (e) => e.target.select());
        }

        function updateCropUI(top, bottom, left, right) {
            cropTopInput.value = cropTopSlider.value = top;
            cropBottomInput.value = cropBottomSlider.value = bottom;
            cropLeftInput.value = cropLeftSlider.value = left;
            cropRightInput.value = cropRightSlider.value = right;
        }

        function updateBlurUI(top, bottom, left, right) {
            blurTopInput.value = blurTopSlider.value = top;
            blurBottomInput.value = blurBottomSlider.value = bottom;
            blurLeftInput.value = blurLeftSlider.value = left;
            blurRightInput.value = blurRightSlider.value = right;
        }

        setupSliderInput(cropTopSlider, cropTopInput, 'top', cropParams);
        setupSliderInput(cropBottomSlider, cropBottomInput, 'bottom', cropParams);
        setupSliderInput(cropLeftSlider, cropLeftInput, 'left', cropParams);
        setupSliderInput(cropRightSlider, cropRightInput, 'right', cropParams);

        setupSliderInput(blurTopSlider, blurTopInput, 'top', blurParams);
        setupSliderInput(blurBottomSlider, blurBottomInput, 'bottom', blurParams);
        setupSliderInput(blurLeftSlider, blurLeftInput, 'left', blurParams);
        setupSliderInput(blurRightSlider, blurRightInput, 'right', blurParams);
        
        let pressTimer, intervalId;
        function incrementValue(target, direction) {
            const inputElement = document.getElementById(`${target}Input`);
            const sliderElement = document.getElementById(`${target}Slider`);
            let currentValue = parseFloat(inputElement.value) || 0;
            let newValue = direction === 'plus' ? currentValue + 0.1 : currentValue - 0.1;
            newValue = Math.max(0, Math.min(newValue, 100.0)).toFixed(1);
            inputElement.value = newValue;
            sliderElement.value = newValue;
            if (target.startsWith('crop')) {
                cropParams[target.replace('crop', '').toLowerCase()] = parseFloat(newValue);
            } else if (target.startsWith('blur')) {
                blurParams[target.replace('blur', '').toLowerCase()] = parseFloat(newValue);
            }
            if (isTransparencyApplied) updatePreview();
        }
        valueControlButtons.forEach(button => {
            const target = button.dataset.target;
            const direction = button.dataset.direction;
            const stopInterval = () => { clearTimeout(pressTimer); clearInterval(intervalId); };
            button.addEventListener('mousedown', (e) => {
                e.preventDefault();
                incrementValue(target, direction);
                pressTimer = setTimeout(() => { intervalId = setInterval(() => incrementValue(target, direction), 50); }, 300);
            });
            button.addEventListener('mouseup', stopInterval);
            button.addEventListener('mouseleave', stopInterval);
            button.addEventListener('touchstart', (e) => { 
                e.preventDefault();
                incrementValue(target, direction);
                pressTimer = setTimeout(() => { intervalId = setInterval(() => incrementValue(target, direction), 50); }, 300);
            }, { passive: false });
            button.addEventListener('touchend', stopInterval);
            button.addEventListener('touchcancel', stopInterval);
        });
        
        toggleAdjustmentsPreviewBtn.addEventListener('click', () => {
            isAdjustmentsPreviewOn = !isAdjustmentsPreviewOn;
            if (isAdjustmentsPreviewOn) {
                toggleAdjustmentsPreviewBtn.classList.add('active');
                toggleAdjustmentsPreviewBtn.textContent = getMessage('previewOn'); 
            } else {
                toggleAdjustmentsPreviewBtn.classList.remove('active');
                toggleAdjustmentsPreviewBtn.textContent = getMessage('previewOff');
            }
            updatePreview(); 
        });

        // ==========================================================
        // ▼▼▼▼▼▼▼▼▼▼▼▼▼ マニュアル透過 イベントリスナー ▼▼▼▼▼▼▼▼▼▼▼▼▼
        // ==========================================================

        // [図形を配置] ボタン
        addShapeBtn.addEventListener('click', () => {
            if (!isTransparencyApplied) {
                statusMessage3.dataset.langKey = 'manualMaskFirst';
                statusMessage3.dataset.langVars = '{}';
                return;
            }
            isAddingShapeMode = !isAddingShapeMode;
            
            if (isAddingShapeMode) {
                statusMessage3.dataset.langKey = 'manualMaskAdd';
                statusMessage3.dataset.langVars = '{}';
            } else {
                statusMessage3.dataset.langKey = 'manualMaskEdit';
                statusMessage3.dataset.langVars = '{}';
            }
            updateCutModeUI();
        });
        
        // キャンバスのクリックイベント (図形追加用)
        previewCanvas.addEventListener('click', (event) => {
            if (!isTransparencyApplied || !isAddingShapeMode) return;
            
            const internalCoords = getInternalCoords(event);
            const size = offscreenCanvas.width * 0.1; 
            const height = size * (Math.sqrt(3) / 2);
            
            const vertices = [
                { x: internalCoords.x, y: internalCoords.y - (2/3) * height }, 
                { x: internalCoords.x - size / 2, y: internalCoords.y + (1/3) * height }, 
                { x: internalCoords.x + size / 2, y: internalCoords.y + (1/3) * height }
            ];

            const newShape = {
                id: Date.now(),
                vertices: vertices
            };
            
            shapes.push(newShape);
            
            isAddingShapeMode = false; 
            statusMessage3.dataset.langKey = 'manualMaskPlaced';
            statusMessage3.dataset.langVars = '{}';
            updateCutModeUI();
            updatePreview(); 
            recordHistory(false); 
        });

        // ドラッグ中のマウス移動
        const handleDocumentMouseMove = (event) => {
            if (!draggingVertex) return;

            const internalCoords = getInternalCoords(event);
            const { shapeId, vertexIndex } = draggingVertex;
            const shape = shapes.find(s => s.id === shapeId);
            if (shape) {
                // ▼▼▼ 制限範囲を拡大 (画像の外側 12.5% まで許容) ▼▼▼
                const imgWidth = offscreenCanvas.width;
                const imgHeight = offscreenCanvas.height;
                const marginX = imgWidth * CANVAS_PADDING_RATIO;
                const marginY = imgHeight * CANVAS_PADDING_RATIO;

                let restrictedX = internalCoords.x;
                let restrictedY = internalCoords.y;

                // マイナス余白 ～ 幅+余白 まで移動可能にする
                restrictedX = Math.max(-marginX, Math.min(imgWidth + marginX, restrictedX));
                restrictedY = Math.max(-marginY, Math.min(imgHeight + marginY, restrictedY));
                
                shape.vertices[vertexIndex].x = restrictedX;
                shape.vertices[vertexIndex].y = restrictedY;
                updatePreview(); 
            }
        };

        // ドラッグ終了
        const handleDocumentMouseUp = (event) => {
            if (!draggingVertex) return;

            draggingVertex = null;
            previewCanvas.classList.remove('grabbing');
            
            updateHoverState(event);

            document.removeEventListener('mousemove', handleDocumentMouseMove);
            document.removeEventListener('mouseup', handleDocumentMouseUp);
            recordHistory(false); 
        };

        

        // キャンバスのMousedown (ドラッグ開始: 図形移動 または パン)
        previewCanvas.addEventListener('mousedown', (event) => {
            // Step3が表示されていない場合は何もしない
            if (stepManualCut.classList.contains('hidden')) return;
            
            // 右クリック等は無視
            if (event.button !== 0) return;

            // ■ 1. 図形追加モードの場合 → (既存処理: 何もしない、clickイベントに任せる)
            if (isAddingShapeMode) return;

            // ■ 2. 頂点や辺をホバーしている場合 → (既存処理: 図形変形)
            if (hoveredVertex) {
                
                draggingVertex = hoveredVertex;
                updateCursorStyle(); 

                document.addEventListener('mousemove', handleDocumentMouseMove);
                document.addEventListener('mouseup', handleDocumentMouseUp);
                return;
            }

            // ■ 3. 何もホバーしていない場合 → パン(移動)開始
            if (!hoveredVertex && !hoveredEdge) {
                isPanning = true;
                startPanX = event.clientX - panX;
                startPanY = event.clientY - panY;
                updateCursorStyle();
                
                // パン用のマウスムーブ/アップイベントを登録
                document.addEventListener('mousemove', handlePanMouseMove);
                document.addEventListener('mouseup', handlePanMouseUp);
            }
        });

        // キャンバスのMousemove (ホバー処理のみ)
        previewCanvas.addEventListener('mousemove', (event) => {
            if (!isTransparencyApplied) return;
            if (draggingVertex || draggingShape) {
                return;
            }
            updateHoverState(event);
        });


        previewCanvas.addEventListener('mouseleave', () => {
            if (!draggingVertex && !draggingShape) {
                hoveredVertex = null;
                hoveredEdge = null;
                previewCanvas.classList.remove('pointer');
            }
        });
        
        // キャンバスの右クリック (コンテキストメニュー)
        previewCanvas.addEventListener('contextmenu', (event) => {
            event.preventDefault(); 
            if (!isTransparencyApplied || isAddingShapeMode) return;

            updateHoverState(event);
            
            let target = null;
            if (hoveredVertex) {
                target = hoveredVertex;
                ctxAddVertex.style.display = 'none';
                ctxDeleteVertex.style.display = 'block';
                ctxDeleteShape.style.display = 'block';
            } else if (hoveredEdge) {
                target = hoveredEdge;
                ctxAddVertex.style.display = 'block';
                ctxDeleteVertex.style.display = 'none';
                ctxDeleteShape.style.display = 'block'; 
            } else {
                shapeContextMenu.style.display = 'none'; 
                return;
            }
            
            contextMenu = {
                visible: true,
                target: target,
                x: event.clientX,
                y: event.clientY
            };
            
            const containerRect = stepCanvasContainer.getBoundingClientRect();
            const menuX = event.clientX - containerRect.left;
            const menuY = event.clientY - containerRect.top;
            const menuWidth = 120;
            const menuHeight = 110; 
            shapeContextMenu.style.left = Math.min(menuX, containerRect.width - menuWidth) + 'px';
            shapeContextMenu.style.top = Math.min(menuY, containerRect.height - menuHeight) + 'px';
            shapeContextMenu.style.display = 'block';
        });

        // メニュー以外をクリックしたら閉じる
        document.addEventListener('click', (event) => {
            if (contextMenu.visible && !shapeContextMenu.contains(event.target)) {
                shapeContextMenu.style.display = 'none';
                contextMenu.visible = false;
            }
        }, true);
        
        // メニュー: 頂点を追加
        ctxAddVertex.addEventListener('click', () => {
            if (!contextMenu.target) return;
            
            const { shapeId, vertexIndex1, vertexIndex2 } = contextMenu.target;
            const shape = shapes.find(s => s.id === shapeId);
            if (shape) {
                const v1 = shape.vertices[vertexIndex1];
                const v2 = shape.vertices[vertexIndex2];
                const newVertex = {
                    x: (v1.x + v2.x) / 2,
                    y: (v1.y + v2.y) / 2
                };
                shape.vertices.splice(vertexIndex2, 0, newVertex);
                updatePreview();
                recordHistory(false);
            }
            shapeContextMenu.style.display = 'none';
            contextMenu.visible = false;
        });

        // メニュー: 頂点を削除
        ctxDeleteVertex.addEventListener('click', () => {
            if (!contextMenu.target) return;
            
            const { shapeId, vertexIndex } = contextMenu.target;
            const shape = shapes.find(s => s.id === shapeId);
            if (shape) {
                if (shape.vertices.length <= 3) {
                    shapes = shapes.filter(s => s.id !== shapeId);
                } else {
                    shape.vertices.splice(vertexIndex, 1);
                }
                updatePreview();
                recordHistory(false);
            }
            shapeContextMenu.style.display = 'none';
            contextMenu.visible = false;
        });

        // メニュー: 図形を削除
        ctxDeleteShape.addEventListener('click', () => {
            if (!contextMenu.target) return;

            const { shapeId } = contextMenu.target;
            shapes = shapes.filter(s => s.id !== shapeId);
            updatePreview();
            recordHistory(false);
            
            shapeContextMenu.style.display = 'none';
            contextMenu.visible = false;
        });

        // メニュー: 閉じる
        ctxCancel.addEventListener('click', () => {
            shapeContextMenu.style.display = 'none';
            contextMenu.visible = false;
        });
        
        // [マニュアル透過処理] ボタン
        applyManualCutBtn.addEventListener('click', () => {
            if (!isTransparencyApplied || shapes.length === 0) {
                statusMessage3.dataset.langKey = 'manualMaskNoShapes';
                statusMessage3.dataset.langVars = '{}';
                return;
            }

            // 2. くり抜き処理
            offscreenCtx.save();
            offscreenCtx.globalCompositeOperation = 'destination-out';
            
            shapes.forEach(shape => {
                if (shape.vertices.length < 3) return;
                
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(shape.vertices[0].x, shape.vertices[0].y);
                for (let i = 1; i < shape.vertices.length; i++) {
                    offscreenCtx.lineTo(shape.vertices[i].x, shape.vertices[i].y);
                }
                offscreenCtx.closePath();
                offscreenCtx.fill(); 
            });
            
            offscreenCtx.restore(); 

            // 3. 図形と履歴をリセット
            shapes = [];
            
            
            updatePreview();
            recordHistory(true); 
            updateHistoryButtons(); // [透過処理を戻す] を有効化
            statusMessage3.dataset.langKey = 'manualMaskApplied';
            statusMessage3.dataset.langVars = '{}';
        });



        // ▼▼▼ 統合履歴ボタンのイベント ▼▼▼
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        if (undoBtn) undoBtn.addEventListener('click', executeUndo);
        if (redoBtn) redoBtn.addEventListener('click', executeRedo);

        // ==========================================================
        // ▼▼▼ DOMContentLoaded ロジック全体 ▼▼▼
        // ==========================================================
        document.addEventListener('DOMContentLoaded', () => {
            // ▼▼▼ URLに ?debug=true がある時だけパネルを表示 ▼▼▼
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('debug') === 'true') {
                const debugPanel = document.getElementById('debugPanel');
                if (debugPanel) {
                    debugPanel.style.display = 'block';
                    console.log("★ デバッグモードで起動しました");
                }
            }
            const themeDarkBtn = document.getElementById('themeDarkBtn');
            const themeLightBtn = document.getElementById('themeLightBtn');

            // テーマを設定し、localStorageに保存する関数
            const setTheme = (theme) => {
                if (theme === 'light') {
                    document.body.classList.add('light-mode');
                    localStorage.setItem('theme', 'light');
                } else {
                    document.body.classList.remove('light-mode');
                    localStorage.setItem('theme', 'dark');
                }

                // ボタンのアクティブ状態を更新
                themeDarkBtn.classList.toggle('active', theme === 'dark');
                themeLightBtn.classList.toggle('active', theme === 'light');

                if (isTransparencyApplied) {
                    updatePreview();
                }
                updateDynamicImages();
            };

            // 1. localStorage から設定を読み込む
            const currentTheme = localStorage.getItem('theme') || 'dark'; // デフォルトを 'dark' に
            setTheme(currentTheme);
            
            // 2. ボタンのクリックイベントを監視
            themeDarkBtn.addEventListener('click', () => setTheme('dark'));
            themeLightBtn.addEventListener('click', () => setTheme('light'));
            tokenIdInput.addEventListener('focus', (e) => e.target.select());
        // 動的な画像 (テーマ/言語) を更新するヘルパー関数
        function updateDynamicImages() {
            // 1. 現在のテーマと言語を取得
            const isLightMode = document.body.classList.contains('light-mode');
            const currentLang = localStorage.getItem('language') || 'jp';
            const themeKey = isLightMode ? 'light' : 'dark';

            // 2. ヘルプパネル内のすべての動的画像を取得
            const dynamicImages = document.querySelectorAll('#helpModal .dynamic-help-image');

            dynamicImages.forEach(img => {
                // 3. data- 属性キーを組み立てる (例: "src-jp-dark")
                const dataKey = `src-${currentLang}-${themeKey}`;
                
                // 4. キーをキャメルケースに変換 (例: "srcJpDark")
                const datasetKey = dataKey.replace(/-(\w)/g, (m, c) => c.toUpperCase());
                
                // 5. 画像パスを取得
                let imgSrc = img.dataset[datasetKey];

                // 6. フォールバック (もしEN画像が未指定ならJP画像、Light画像が未指定ならDark画像)
                if (!imgSrc) {
                    const fallbackLangKey = `src-jp-${themeKey}`.replace(/-(\w)/g, (m, c) => c.toUpperCase());
                    imgSrc = img.dataset[fallbackLangKey];
                }
                if (!imgSrc) {
                    const fallbackThemeKey = `src-${currentLang}-dark`.replace(/-(\w)/g, (m, c) => c.toUpperCase());
                    imgSrc = img.dataset[fallbackThemeKey];
                }
                if (!imgSrc) {
                    imgSrc = img.dataset['srcJpDark']; // 最終フォールバック
                }

                // 7. 必要な場合のみ src を更新
                if (imgSrc && img.src !== imgSrc) {
                    img.src = imgSrc;
                }
            });
        }
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            // ▼▼▼ 動画の最終フレーム停止ロジック ▼▼▼
            // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
            
            const videoDark = document.querySelector('.logo-video-dark');
            const videoLight = document.querySelector('.logo-video-light');

            const keepLastFrame = (videoElement) => {
                if (!videoElement) return;
                
                // 'timeupdate' (再生時間が更新される) たびにチェック
                videoElement.addEventListener('timeupdate', () => {
                    // 動画の総再生時間 (duration) が取得できていて、
                    // 現在の再生時間 (currentTime) が「ほぼ最後」 (終了0.1秒前) になったら
                    if (videoElement.duration && videoElement.currentTime >= videoElement.duration - 0.1) {
                        
                        // 'ended' (再生終了) イベントが発火する前に、手動で 'pause' (一時停止) させる
                        videoElement.pause();
                    }
                });
                
                // 念のため、何らかの理由で timeupdate が発火しなかった場合を考慮し、
                // 'ended' イベントでも pause() を呼ぶ
                videoElement.addEventListener('ended', () => {
                    videoElement.pause();
                });
            };

            keepLastFrame(videoDark);
            keepLastFrame(videoLight);
            
            const langJpBtn = document.getElementById('langJpBtn');
            const langEnBtn = document.getElementById('langEnBtn');

            // 言語を設定し、localStorageに保存する関数
            const setLanguage = (lang) => {
                // 3. localStorageに保存
                localStorage.setItem('language', lang);
                // 1. data-lang-jp 属性を持つ要素 (静的テキスト) を更新
                const elementsToTranslate = document.querySelectorAll('[data-lang-jp]');
                
                elementsToTranslate.forEach(el => {
                    let text = '';
                    if (lang === 'en') {
                        text = el.dataset.langEn || el.dataset.langJp;
                    } else {
                        text = el.dataset.langJp;
                    }
                    
                    // プレビューボタンと図形配置ボタンは状態によってテキストが変わるため、
                    // 状態に応じたテキストを getMessage から取得しなおす
                    if (el.id === 'toggleAdjustmentsPreviewBtn') {
                        el.textContent = isAdjustmentsPreviewOn ? getMessage('previewOn') : getMessage('previewOff');
                    } else if (el.id === 'addShapeBtn') {
                        el.textContent = isAddingShapeMode ? getMessage('addShapeOn') : getMessage('addShape');
                    } else {
                        el.innerHTML = text; 
                    }
                });

                // 1b. [★特殊対応★] プレースホルダーを更新
                const placeholdersToTranslate = document.querySelectorAll('[data-lang-placeholder-jp]');
                placeholdersToTranslate.forEach(el => {
                    if (lang === 'en') {
                        el.placeholder = el.dataset.langPlaceholderEn || el.dataset.langPlaceholderJp;
                    } else {
                        el.placeholder = el.dataset.langPlaceholderJp;
                    }
                });
                
                // 1c. [★特殊対応★] 画像のaltテキストを更新
                const altsToTranslate = document.querySelectorAll('[data-lang-alt-jp]');
                altsToTranslate.forEach(el => {
                    if (lang === 'en') {
                        el.alt = el.dataset.langAltEn || el.dataset.langAltJp;
                    } else {
                        el.alt = el.dataset.langAltJp;
                    }
                });

                // 2. [★アップグレード★] data-lang-key 属性を持つ要素 (動的メッセージ) を更新
                const dynamicMessages = document.querySelectorAll('[data-lang-key]');
                dynamicMessages.forEach(el => {
                    const key = el.dataset.langKey;
                    if (key) {
                        try {
                            const vars = JSON.parse(el.dataset.langVars || '{}');
                            // メッセージストアから新しい言語のテキストを取得して再設定
                            el.textContent = getMessage(key, vars);
                        } catch (e) {
                            console.error('Failed to re-translate dynamic message:', e);
                        }
                    }
                });

                
                updateDynamicImages(); // 動的画像を更新
                // 4. UIの状態を更新 (例: JP/EN ボタンのアクティブ化など)
                langJpBtn.classList.toggle('active', lang === 'jp');
                langEnBtn.classList.toggle('active', lang === 'en');
            };

            // ページ読み込み時に、保存された言語を適用 (デフォルトは 'jp')
            const currentLang = localStorage.getItem('language') || 'jp';
            setLanguage(currentLang);

            // ボタンのクリックイベント
            langJpBtn.addEventListener('click', () => setLanguage('jp'));
            langEnBtn.addEventListener('click', () => setLanguage('en'));

            // ==========================================================
            // ▼▼▼ ヘルプモーダルロジック ▼▼▼
            // ==========================================================
            
            // モーダル関連の要素を取得
            const helpModalOverlay = document.getElementById('helpModalOverlay');
            const helpModal = document.getElementById('helpModal');
            const closeModalBtn = document.getElementById('closeModalHandle');
            const helpIcons = document.querySelectorAll('.help-icon');

            // モーダルを開く関数
            const openModal = (helpId) => {
                // すべてのヘルプコンテンツを一旦非表示にする
                const allHelpContents = document.querySelectorAll('#helpContent [data-help-id]');
                allHelpContents.forEach(el => el.classList.add('hidden'));

                // 対象のヘルプコンテンツ（例: data-help-id="step0"）だけを表示する
                const targetContent = document.querySelector(`#helpContent [data-help-id="${helpId}"]`);
                if (targetContent) {
                    targetContent.classList.remove('hidden');
                } else {
                    // デフォルト（step0）を表示する
                    const defaultContent = document.querySelector(`#helpContent [data-help-id="step0"]`);
                    if (defaultContent) defaultContent.classList.remove('hidden');
                }
                
                // モーダルを開く
                helpModalOverlay.classList.remove('hidden'); /* 背景は即座に表示 */
                
                requestAnimationFrame(() => {
                    helpModal.classList.add('is-open');
                });
                
                // 多言語を再適用（モーダルを開くたびに最新の言語設定を反映）
                setLanguage(localStorage.getItem('language') || 'jp');
                // モーダルが開いたら、スクロール位置を一番上に戻す
                helpModal.scrollTop = 0;
            };

            // モーダルを閉じる関数
 
           const closeModal = () => {
                helpModal.classList.remove('is-open');
                
                // 背景はアニメーションが終わる頃（0.4秒）に合わせて消す
                setTimeout(() => {
                    helpModalOverlay.classList.add('hidden');
                }, 400); // CSSのtransition時間（0.4s）と合わせる
            };

            // ▼▼▼ 各ヘルプアイコンにクリックイベントを設定 ▼▼▼
            helpIcons.forEach(icon => {
                icon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // アイコンが持つ data-help-target 属性（例: "step0"）を取得する
                    const helpTargetId = e.currentTarget.dataset.helpTarget || 'step0'; // デフォルトは 'step0'
                    
                    openModal(helpTargetId);
                });
            });

            // 閉じるボタン (×) のクリックイベント
            closeModalBtn.addEventListener('click', closeModal);

            // オーバーレイ (外側) のクリックイベント
            helpModalOverlay.addEventListener('click', closeModal);

            // モーダルウィンドウ (パネル) 自体をクリックしても閉じないようにする
            helpModal.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            // ▼▼▼ ヘルプ画像の右クリック禁止 (保存防止) ▼▼▼
            const helpImages = document.querySelectorAll('.help-content-image');
            helpImages.forEach(img => {
                // 右クリック (コンテキストメニュー) を無効化
                img.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                // ドラッグによる保存も防ぐ
                img.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            });
        });

        // ==========================================================
        // ▼▼▼ リロード運用型 バッチ処理ロジック ▼▼▼
        // ==========================================================
        
        const batchStartId = document.getElementById('batchStartId');
        const batchEndId = document.getElementById('batchEndId');
        const startBatchBtn = document.getElementById('startBatchBtn');
        const stopBatchBtn = document.getElementById('stopBatchBtn');
        const batchLog = document.getElementById('batchLog');
        
        // LocalStorageのキー定義
        const LS_KEY_STATUS = 'krg_debug_status';
        const LS_KEY_CURRENT = 'krg_debug_current';
        const LS_KEY_END = 'krg_debug_end';

        const logBatch = (msg) => {
            const div = document.createElement('div');
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            batchLog.appendChild(div);
            batchLog.scrollTop = batchLog.scrollHeight;
        };

        const saveImageToServer = async (filename, canvas) => {
            const imageData = canvas.toDataURL('image/png');
            try {
                const res = await fetch('/api/save-debug-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename, imageData })
                });
                if (!res.ok) throw new Error('Server error');
            } catch (e) {
                console.error(`保存エラー: ${filename}`, e);
                logBatch(`Error saving ${filename}: ${e.message}`);
            }
        };

        const getResizedCanvas = (sourceCanvas, targetSize = 3840) => {
            const canvas = document.createElement('canvas');
            const scale = targetSize / sourceCanvas.width;
            canvas.width = targetSize;
            canvas.height = sourceCanvas.height * scale;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(sourceCanvas, 0, 0, canvas.width, canvas.height);
            return canvas;
        };

        // 1つのIDを処理する関数
        const processSingleId = async (id) => {
            try {
                logBatch(`ID: ${id} 処理開始...`);
                
                // 1. データ取得
                tokenIdInput.value = id;
                fetchDataBtn.click();

                // 完了待機
                await new Promise(resolve => {
                    const check = setInterval(() => {
                        const msg = statusMessage1.textContent;
                        if (msg.includes('完了') || msg.includes('Success')) {
                            clearInterval(check);
                            resolve(true);
                        } else if (msg.includes('エラー') || msg.includes('Error') || msg.includes('半角数字')) {
                            clearInterval(check);
                            resolve(false);
                        }
                    }, 500);
                });

                const currentMsg = statusMessage1.textContent;
                if (currentMsg.includes('エラー') || currentMsg.includes('Error') || currentMsg.includes('半角数字')) {
                    logBatch(`ID: ${id} データ取得失敗。スキップします。`);
                    // エラーでも次に進む
                } else {
                    // 画像ロード待ち (リロード運用なら短くてOK)
                    await new Promise(r => setTimeout(r, 1500));

                    // 2. オリジナル保存
                    if (nftImage) {
                        const tempC = document.createElement('canvas');
                        tempC.width = nftImage.width;
                        tempC.height = nftImage.height;
                        tempC.getContext('2d').drawImage(nftImage, 0, 0);
                        const resized = getResizedCanvas(tempC, 3840);
                        await saveImageToServer(`KRG_${id}.png`, resized);
                    }

                    // 3. 各モード実行
                    const modes = ['head', 'headBody', 'headBodyBg'];
                    for (const mode of modes) {
                        handleModeChange(mode, document.getElementById(mode + 'Btn'));
                        
                        // A. 通常切り抜き
                        await applyTransparency(false); 
                        await new Promise(r => setTimeout(r, 500)); 
                        let resized = getResizedCanvas(offscreenCanvas, 3840);
                        let areaName = mode === 'head' ? 'Head' : (mode === 'headBody' ? 'HeadBody' : 'HeadBodyBg');
                        await saveImageToServer(`KRG_${id}_${areaName}_Mask_3840px.png`, resized);

                        // B. 補完切り抜き
                        const canRecovery = hasRecoveryLayers; 
                        if (canRecovery) {
                            await applyTransparency(true);
                            await new Promise(r => setTimeout(r, 500));
                            let resizedRec = getResizedCanvas(offscreenCanvas, 3840);
                            await saveImageToServer(`KRG_${id}_${areaName}_Recovery_3840px.png`, resizedRec);
                        }
                    }
                    logBatch(`ID: ${id} 保存完了`);
                }

                const nextId = id + 1;
                const endId = parseInt(localStorage.getItem(LS_KEY_END));

                if (nextId > endId) {
                    // 終了
                    localStorage.setItem(LS_KEY_STATUS, 'stopped');
                    logBatch(`=== 全処理終了 (ID: ${endId} まで) ===`);
                    startBatchBtn.disabled = false;
                    stopBatchBtn.disabled = true;
                    alert('バッチ処理が完了しました！');
                } else {
                    // 次へ (リロード)
                    localStorage.setItem(LS_KEY_CURRENT, nextId);
                    logBatch(`次のID (${nextId}) へリロードします...`);
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                }

            } catch (err) {
                console.error(err);
                logBatch(`予期せぬエラー: ${err}`);
                // エラーでも止まらず次に進む (無限ループ防止のため)
                const nextId = id + 1;
                localStorage.setItem(LS_KEY_CURRENT, nextId);
                setTimeout(() => window.location.reload(), 1000);
            }
        };

        // ページ読み込み時にバッチ状態をチェック
        const checkBatchStatus = () => {
            const status = localStorage.getItem(LS_KEY_STATUS);
            if (status === 'running') {
                const current = parseInt(localStorage.getItem(LS_KEY_CURRENT));
                const end = parseInt(localStorage.getItem(LS_KEY_END));
                
                // UI復元
                batchStartId.value = current;
                batchEndId.value = end;
                startBatchBtn.disabled = true;
                stopBatchBtn.disabled = false;
                
                logBatch(`バッチ自動再開: ID ${current} / ${end}`);
                
                // 処理開始
                processSingleId(current);
            }
        };

        // 開始ボタン
        if (startBatchBtn) {
            startBatchBtn.addEventListener('click', () => {
                const start = parseInt(batchStartId.value);
                const end = parseInt(batchEndId.value);
                
                // 状態を保存してリロード
                localStorage.setItem(LS_KEY_STATUS, 'running');
                localStorage.setItem(LS_KEY_CURRENT, start);
                localStorage.setItem(LS_KEY_END, end);
                
                startBatchBtn.disabled = true;
                stopBatchBtn.disabled = false;
                logBatch("バッチ処理を開始します (リロード待機)...");
                
                window.location.reload();
            });
        }

        // 停止ボタン
        if (stopBatchBtn) {
            stopBatchBtn.addEventListener('click', () => {
                localStorage.setItem(LS_KEY_STATUS, 'stopped');
                startBatchBtn.disabled = false;
                stopBatchBtn.disabled = true;
                logBatch("停止しました。(次のリロードは行われません)");
            });
        }

        // 起動チェック
        checkBatchStatus();

        // ==========================================================
        // ▼▼▼ ズーム＆パン機能の実装 ▼▼▼
        // ==========================================================
        
        let zoomLevel = 100; // %単位
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startPanX = 0;
        let startPanY = 0;

        const zoomSlider = document.getElementById('zoomSlider');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomValueLabel = document.getElementById('zoomValueLabel');
        const zoomTicksContainer = document.getElementById('zoomTicks');
        const zoomTickValues = [80, 100, 150, 200, 250, 300, 350, 400];

        // 目盛りのDOM生成
        function initZoomTicks() {
            zoomTicksContainer.innerHTML = '';
            const min = 80;
            const max = 400;
            const range = max - min;
            
            // ★重要: CSSで設定した「つまみの幅」と合わせる (現在は8px)
            const thumbWidth = 8; 

            zoomTickValues.forEach(val => {
                const tick = document.createElement('div');
                tick.className = 'zoom-tick';
                
                // 割合 (0.0 ~ 1.0)
                const ratio = (val - min) / range;
                
                // ▼▼▼ つまみの可動域に合わせて位置を補正する ▼▼▼
                // 単純な%ではなく、つまみの半径(4px)分だけ内側にオフセットした座標系を使う
                // 式: 4px + (全体幅 - 8px) * 割合
                tick.style.left = `calc(${thumbWidth/2}px + (100% - ${thumbWidth}px) * ${ratio})`;
                tick.textContent = val; 
                
                // 数値をクリックしたらその倍率へジャンプ
                tick.addEventListener('click', () => {
                    setZoom(val);
                });

                zoomTicksContainer.appendChild(tick);
            });
        }
        initZoomTicks();

        // ズームとパンを適用する関数
        function applyZoomPan() {
            if (!previewCanvas) return;
            // ▼▼▼ ズーム倍率の基準を変更 ▼▼▼
            // キャンバスが実質 125% (1/0.8) のサイズになっているため、
            // scale(1.0) のとき、画像は 80% サイズで見える (これがスライダー80%の状態)。
            // したがって、scale の計算式は (zoomLevel / 80) となる。
            const cssScale = zoomLevel / 80;
            
            previewCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${cssScale})`;

            // スライダーとラベルの同期
            zoomSlider.value = zoomLevel;
            zoomValueLabel.textContent = `${Math.round(zoomLevel)}%`;

            updateCursorStyle();
            // ▼▼▼ マニュアル切り抜き画面が表示されている時だけ再描画する ▼▼▼
            // これにより、Step2でボタンを押した時に勝手にプレビューが更新されるのを防ぎつつ、
            // Step3でのズーム操作時には線の太さを最適化できます。
            if (!stepManualCut.classList.contains('hidden')) {
                updatePreview();
            }
        }

        function updateCursorStyle() {
            if (stepManualCut.classList.contains('hidden')) return;

            // ▼▼▼ コンテナに対してクラスを付与 ▼▼▼
            if (isPanning || draggingVertex) {
                stepCanvasContainer.classList.add('grabbing-cursor');
                stepCanvasContainer.classList.remove('grab-cursor');
                previewCanvas.classList.remove('pointer', 'crosshair');
                return;
            }
            
            // 図形操作モードのときは、キャンバス上のカーソルを優先
            if (isAddingShapeMode || hoveredVertex || hoveredEdge) {
                stepCanvasContainer.classList.remove('grab-cursor', 'grabbing-cursor');
                return;
            }
            
            // それ以外はパン可能
            stepCanvasContainer.classList.add('grab-cursor');
            stepCanvasContainer.classList.remove('grabbing-cursor');
        }

        function setZoom(newLevel, originX = null, originY = null) {
            // 1. 範囲制限 (80~400)
            newLevel = Math.max(80, Math.min(400, newLevel));
            
            // 2. 100%(等倍)スナップ時の強制リセット (位置もリセット)
            if (Math.abs(newLevel - 100) < 0.1) {
                newLevel = 100;
                panX = 0;
                panY = 0;
                zoomLevel = newLevel;
                applyZoomPan();
                return;
            } else if (newLevel < 100) {
                // 100%未満は中央固定
                panX = 0;
                panY = 0;
                zoomLevel = newLevel;
                applyZoomPan();
                return;
            }

            // 3. 変化比率 (Ratio) の計算
            const oldLevel = zoomLevel;
            const ratio = newLevel / oldLevel;

            // 4. Pan位置の更新
            // originX/Y (中心点) が指定されている場合 (マウスホイール): その位置を中心に拡大
            // 指定されていない場合 (null / スライダー): コンテナ中心(0,0)を基準に拡大
            // 
            // ★重要: 「コンテナ中心(0,0)」を基準にする場合、計算式は panX = panX * ratio となります。
            // これにより、「現在画面の中央に見えている地点」が、ズーム後も画面中央に維持されます。
            // (ドラッグで位置調整した後でも、その場所がズレなくなります)
            
            const centerBaseX = originX !== null ? originX : 0;
            const centerBaseY = originY !== null ? originY : 0;

            // 公式: NewPan = OldPan * Ratio + Origin * (1 - Ratio)
            panX = panX * ratio + centerBaseX * (1 - ratio);
            panY = panY * ratio + centerBaseY * (1 - ratio);

            // 5. ズーム値の更新
            zoomLevel = newLevel;

            // 6. 移動範囲の制限 (Clamp)
            // 拡大後の画像サイズ - コンテナの80%サイズ
            const rect = stepCanvasContainer.getBoundingClientRect();
            const maxPanX = (rect.width * (zoomLevel / 100) - rect.width * 0.80) / 2;
            const maxPanY = (rect.height * (zoomLevel / 100) - rect.height * 0.80) / 2;
            
            panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
            panY = Math.max(-maxPanY, Math.min(maxPanY, panY));

            applyZoomPan();
        }

        // スライダー操作 -> 中心指定なし(null) = コンテナ中心(0,0)基準で拡大
        // これにより、ドラッグした位置をキープしたまま拡大縮小できます
        zoomSlider.addEventListener('input', (e) => {
            setZoom(Number(e.target.value), null, null);
        });

        // (+) ボタン -> 中心指定なし = コンテナ中心基準
        zoomInBtn.addEventListener('click', () => {
            const nextTick = zoomTickValues.find(v => v > zoomLevel);
            setZoom(nextTick || 400, null, null);
        });

        // (-) ボタン -> 中心指定なし = コンテナ中心基準
        zoomOutBtn.addEventListener('click', () => {
            const prevTick = [...zoomTickValues].reverse().find(v => v < zoomLevel);
            setZoom(prevTick || 80, null, null);
        });

        // マウスホイール操作
        let wheelLockTimer = null;
        let isWheelLockedAt100 = false;

        stepCanvasContainer.addEventListener('wheel', (e) => {
            if (stepManualCut.classList.contains('hidden')) return;
            e.preventDefault();

            // 1. ロック制御 (デバウンス)
            clearTimeout(wheelLockTimer);
            wheelLockTimer = setTimeout(() => {
                isWheelLockedAt100 = false; 
            }, 200);

            if (isWheelLockedAt100) return;

            // 2. マウス位置の計算 (コンテナ中心からの相対座標)
            const rect = stepCanvasContainer.getBoundingClientRect();
            
            // コンテナ内でのマウス座標 (左上基準)
            const rawMouseX = e.clientX - rect.left;
            const rawMouseY = e.clientY - rect.top;

            // コンテナ中心からの相対座標 (中心=0)
            const mouseX = rawMouseX - rect.width / 2;
            const mouseY = rawMouseY - rect.height / 2;

            const delta = -Math.sign(e.deltaY) * 10;
            const currentZ = zoomLevel;
            const nextZ = currentZ + delta;

            // 3. 100% ロック判定
            if ((currentZ < 100 && nextZ >= 100) || (currentZ > 100 && nextZ <= 100)) {
                setZoom(100, null, null); // 100%スナップ時は強制中央リセット
                isWheelLockedAt100 = true;
            } else {
                // 4. マウスがコンテナ内にある場合のみ、マウス位置中心でズーム
                // (念のため、マウス座標がコンテナの範囲内かチェック)
                if (rawMouseX >= 0 && rawMouseX <= rect.width && rawMouseY >= 0 && rawMouseY <= rect.height) {
                    setZoom(nextZ, mouseX, mouseY);
                } else {
                    // コンテナ外にマウスがある場合は、コンテナ中心基準でズーム
                    setZoom(nextZ, null, null);
                }
            }
            
        }, { passive: false });

        // ▼▼▼ ズームリセット関数 ▼▼▼
        function resetZoomPan() {
            zoomLevel = 100;
            panX = 0;
            panY = 0;
            applyZoomPan();
        }

        // ▼▼▼ パン(移動)操作用のイベントハンドラ ▼▼▼
        const handlePanMouseMove = (event) => {
            if (!isPanning) return;
            
            // 一旦、新しい位置を計算
            let newPanX = event.clientX - startPanX;
            let newPanY = event.clientY - startPanY;

            // 移動範囲の制限ロジック (80%基準)
            if (zoomLevel <= 80) {
                newPanX = 0;
                newPanY = 0;
            } else {
                const rect = stepCanvasContainer.getBoundingClientRect();
                // 拡大後の画像サイズ - コンテナの80%サイズ
                const maxPanX = (rect.width * (zoomLevel / 100) - rect.width * 0.80) / 2;
                const maxPanY = (rect.height * (zoomLevel / 100) - rect.height * 0.80) / 2;

                // 範囲内に収める (Clamp)
                newPanX = Math.max(-maxPanX, Math.min(maxPanX, newPanX));
                newPanY = Math.max(-maxPanY, Math.min(maxPanY, newPanY));
            }

            panX = newPanX;
            panY = newPanY;
            
            applyZoomPan();
        };

        const handlePanMouseUp = () => {
            isPanning = false;
            updateCursorStyle();
            document.removeEventListener('mousemove', handlePanMouseMove);
            document.removeEventListener('mouseup', handlePanMouseUp);
        };

        // ▼▼▼ イベント対象をコンテナに変更（余白でもドラッグ可能に） ▼▼▼
        stepCanvasContainer.addEventListener('mousedown', (event) => {
            if (stepManualCut.classList.contains('hidden')) return;
            
            if (event.button !== 0) return;

            // 1. 図形追加モードの場合 → 何もしない（clickイベントに任せる）
            if (isAddingShapeMode) return;

            // 2. 頂点や辺をホバーしている場合 → 図形変形（これはCanvas上の判定が必要）
            if (hoveredVertex) {
                draggingVertex = hoveredVertex;
                updateCursorStyle();

                document.addEventListener('mousemove', handleDocumentMouseMove);
                document.addEventListener('mouseup', handleDocumentMouseUp);
                return;
            }

            // 3. それ以外（余白含む） → パン(移動)開始
            if (!hoveredVertex && !hoveredEdge) {
                isPanning = true;
                // 現在のマウス位置から、現在のpan値を引いて「開始基準点」とする
                startPanX = event.clientX - panX;
                startPanY = event.clientY - panY;
                updateCursorStyle();
                
                document.addEventListener('mousemove', handlePanMouseMove);
                document.addEventListener('mouseup', handlePanMouseUp);
            }
        });


        // ▼▼▼ ショートカットキー (Ctrl+Z, Ctrl+Y) ▼▼▼
        document.addEventListener('keydown', (e) => {
            // マニュアル切り抜き画面が表示されていない時は無効
            if (stepManualCut.classList.contains('hidden')) return;

            // Ctrl (MacはMeta) キーが押されているか
            const isCtrl = e.ctrlKey || e.metaKey;
            
            if (isCtrl && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                
                if (e.shiftKey) {
                    // Ctrl + Shift + Z (Redo)
                    executeRedo();
                } else {
                    // Ctrl + Z (Undo)
                    executeUndo();
                }
            } else if (isCtrl && e.key.toLowerCase() === 'y') {
                // Ctrl + Y (Redo)
                e.preventDefault();
                executeRedo();
            }
        });
    </script>
</body>
</html>